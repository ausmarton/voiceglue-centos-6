<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenVXI: VXIinetInterface Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>VXIinetInterface Struct Reference<br>
<small>
[<a class="el" href="group___v_x_iinet.html">Internet Interface</a>]</small>
</h1><code>#include &lt;VXIinet.h&gt;</code>
<p>
<a href="struct_v_x_iinet_interface-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Abstract interface for accessing Internet functionality including HTTP requests, local file access, URL caching, and cookie access. 
<p>
The interface is a synchronous interface based on the ANSI/ISO C standard file I/O interface, the only exception is that pre-fetches are asynchronous. The client of the interface may use this in an asynchronous manner by using non-blocking I/O operations, creating threads, or by invoking this from a separate server process. <p>
There is one Internet interface per thread/line. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iinet_interface.html#o0">GetVersion</a> )(void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the VXI interface version implemented.  <a href="#o0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iinet_interface.html#o1">GetImplementationName</a> )(void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of the implementation.  <a href="#o1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iinet_interface.html#o2">Prefetch</a> )(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *moduleName, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *name, <a class="el" href="group___v_x_iinet.html#ga59">VXIinetOpenMode</a> mode, <a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a> flags, const VXIMap *properties)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prefetch information (non-blocking).  <a href="#o2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iinet_interface.html#o3">Open</a> )(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *moduleName, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *name, <a class="el" href="group___v_x_iinet.html#ga59">VXIinetOpenMode</a> mode, <a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a> flags, const VXIMap *properties, VXIMap *streamInfo, VXIinetStream **stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a stream for reading or writing.  <a href="#o3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iinet_interface.html#o4">Close</a> )(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, VXIinetStream **stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a previously opened stream Close a stream that was previously opened.  <a href="#o4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iinet_interface.html#o5">Read</a> )(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, <a class="el" href="group___v_x_itypes.html#ga1">VXIbyte</a> *buffer, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> buflen, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> *nread, VXIinetStream *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from a stream.  <a href="#o5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iinet_interface.html#o6">Write</a> )(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga1">VXIbyte</a> *buffer, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> buflen, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> *nwritten, VXIinetStream *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a stream.  <a href="#o6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iinet_interface.html#o7">SetCookieJar</a> )(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, const VXIVector *jar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the cookie jar.  <a href="#o7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iinet_interface.html#o8">GetCookieJar</a> )(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, VXIVector **jar, <a class="el" href="group___v_x_itypes.html#ga0">VXIbool</a> *changed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the cookie jar.  <a href="#o8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iinet_interface.html#o9">GetAbsoluteName</a> )(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *moduleName, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *name, const VXIMap *properties, VXIString **absoluteName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get absolute URI.  <a href="#o9"></a><br></td></tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="o4" doxytag="VXIinetInterface::Close"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(* <a class="el" href="struct_v_x_iinet_interface.html#o4">VXIinetInterface::Close</a>)(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, VXIinetStream **stream)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close a previously opened stream Close a stream that was previously opened. 
<p>
Closing a NULL or previously closed stream will result in an error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>[IN/OUT] Stream to close</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIinet_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o9" doxytag="VXIinetInterface::GetAbsoluteName"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(* <a class="el" href="struct_v_x_iinet_interface.html#o9">VXIinetInterface::GetAbsoluteName</a>)(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *moduleName, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *name, const VXIMap *properties, VXIString **absoluteName)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get absolute URI. 
<p>
To get the canonical absolute URI from a base/relative URI pair. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>moduleName</em>&nbsp;</td><td>[IN] Name of the software module that is outputting the error. See the top of <a class="el" href="_v_x_ilog_8h.html">VXIlog.h</a> for moduleName allocation rules. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>[IN] Name of the data to canonicalize, see above for supported types </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>[IN] Properties to control the canonicalization, may be NULL. Of particular note are: INET_URL_BASE, base URL for resolving relative URLs INET_URL_QUERY_ARGS, map containing key/value pairs for HTTP queries, where the name of each key is the query argument name, and the value of each key is a VXIValue subclass that provides the value for that argument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>absoluteName</em>&nbsp;</td><td>[OUT] The absolute URI after the canonicalization, may be NULL if an error occured.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIinet_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o8" doxytag="VXIinetInterface::GetCookieJar"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(* <a class="el" href="struct_v_x_iinet_interface.html#o8">VXIinetInterface::GetCookieJar</a>)(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, VXIVector **jar, <a class="el" href="group___v_x_itypes.html#ga0">VXIbool</a> *changed)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the cookie jar. 
<p>
The caller of VXIinet is responsible for persistent storage of the cookie jar if desired. This is done by calling <a class="el" href="struct_v_x_iinet_interface.html#o7">SetCookieJar( )</a> with the caller's cookie jar at the start of each call (use an empty cookie jar if this is a new caller), then calling this function to retrieve the updated cookie jar at the end of the call for storage. When the cookie jar is returned, any expired cookies will have been deleted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>jar</em>&nbsp;</td><td>[OUT] Cookie jar, returned as a newly allocated VXIVector (see the description of the cookie jar structure above, it may be empty). The client is responsible for destroying this via <a class="el" href="group___v_x_ivalue.html#ga57">VXIVectorDestroy( )</a> when appropriate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>changed</em>&nbsp;</td><td>[OUT] Flag to indicate whether the cookie jar has been modified since <a class="el" href="struct_v_x_iinet_interface.html#o7">SetCookieJar( )</a>, allows suppressing the write of the cookie jar to persistant storage when that operation is expensive. Pass NULL if this information is not desired.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIinet_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o1" doxytag="VXIinetInterface::GetImplementationName"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a>*(* <a class="el" href="struct_v_x_iinet_interface.html#o1">VXIinetInterface::GetImplementationName</a>)(void)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the name of the implementation. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Implementation defined string that must be different from all other implementations. The recommended name is one where the interface name is prefixed by the implementator's Internet address in reverse order, such as com.xyz.rec for VXIrec from xyz.com. This is similar to how VoiceXML 1.0 recommends defining application specific error types. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o0" doxytag="VXIinetInterface::GetVersion"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a>(* <a class="el" href="struct_v_x_iinet_interface.html#o0">VXIinetInterface::GetVersion</a>)(void)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the VXI interface version implemented. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>VXIint32 for the version number. The high high word is the major version number, the low word is the minor version number, using the native CPU/OS byte order. The current version is VXI_CURRENT_VERSION as defined in <a class="el" href="_v_x_itypes_8h.html">VXItypes.h</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o3" doxytag="VXIinetInterface::Open"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(* <a class="el" href="struct_v_x_iinet_interface.html#o3">VXIinetInterface::Open</a>)(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *moduleName, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *name, <a class="el" href="group___v_x_iinet.html#ga59">VXIinetOpenMode</a> mode, <a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a> flags, const VXIMap *properties, VXIMap *streamInfo, VXIinetStream **stream)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open a stream for reading or writing. 
<p>
All implementations must support opening a URL for reading using <a href="file://">file://</a> or <a href="http://">http://</a> access, and opening a platform dependant path for reading. All implementations must support all the flags for each of the above. For all other combinations support is implementation dependant (i.e. write for URLs and platform dependant paths). <p>
For URLs, the only accepted unsafe characters are: { } [ ] ^ ~ ' They will be escaped if only when processing a HTTP request. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>moduleName</em>&nbsp;</td><td>[IN] Name of the software module that is outputting the error. See the top of <a class="el" href="_v_x_ilog_8h.html">VXIlog.h</a> for moduleName allocation rules. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>[IN] Name of the data to fetch, see above for supported types </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>[IN] Mode to open the data with, an INET_MODE value as defined above </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>[IN] Flags to control the open: INET_FLAG_NONBLOCKING_IO, non-blocking reads and writes, although the open and close is still blocking </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>[IN] Properties to control the open, as listed above. May be NULL. Of particular note are: INET_URL_BASE, base URL for resolving relative URLs INET_URL_QUERY_ARGS, map containing key/value pairs for HTTP queries, where the name of each key is the query argument name, and the value of each key is a VXIValue subclass that provides the value for that argument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streamInfo</em>&nbsp;</td><td>[OUT] (Optional, pass NULL if not required) Map that will be populated with information about the stream. See the INET_INFO_[...] keys listed above, with the implementation possibly setting other keys </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>[OUT] Handle to the opened stream</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIinet_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o2" doxytag="VXIinetInterface::Prefetch"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(* <a class="el" href="struct_v_x_iinet_interface.html#o2">VXIinetInterface::Prefetch</a>)(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *moduleName, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *name, <a class="el" href="group___v_x_iinet.html#ga59">VXIinetOpenMode</a> mode, <a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a> flags, const VXIMap *properties)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prefetch information (non-blocking). 
<p>
Note that this is optional, it does not need to be called prior to <a class="el" href="struct_v_x_iinet_interface.html#o3">Open( )</a>. <p>
Use the INET_PREFETCH_PRIORITY property to provide a hint to indicate the priority of the prefetch. Note that the implementation may opt to ignore the prefetch request (for example a low priority prefetch when the cache is already full with frequently used information). <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>moduleName</em>&nbsp;</td><td>[IN] Name of the software module that is outputting the error. See the top of <a class="el" href="_v_x_ilog_8h.html">VXIlog.h</a> for moduleName allocation rules. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>[IN] Name of the data to fetch, see <a class="el" href="struct_v_x_iinet_interface.html#o3">Open( )</a> for a description of supported types </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>[IN] Reserved for future use, pass INET_MODE_READ </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>[IN] Reserved for future use, pass 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>[IN] Properties to control the prefetch, as listed above. May be NULL. Of particular note are: INET_PREFETCH_PRIORITY, hint to indicate whether and how soon to prefetch the data INET_URL_BASE, base URL for resolving relative URLs INET_URL_QUERY_ARGS, map containing key/value pairs for HTTP queries, where the name of each key is the query argument name, and the value of each key is a VXIValue subclass that provides the value for that argument</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIinet_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o5" doxytag="VXIinetInterface::Read"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(* <a class="el" href="struct_v_x_iinet_interface.html#o5">VXIinetInterface::Read</a>)(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, <a class="el" href="group___v_x_itypes.html#ga1">VXIbyte</a> *buffer, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> buflen, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> *nread, VXIinetStream *stream)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read from a stream. 
<p>
This may or not block, as determined by the flags used when opening the stream. When in non-blocking mode, partial buffers may be returned instead of blocking, or an VXIinet_RESULT_WOULD_BLOCK error is returned if no data is available at all.<p>
NOTE: VXIinet_RESULT_END_OF_STREAM may be returned even when nread is greater then 0. Example: if there are 20 more bytes remaining in a stream and the client component requests 50 bytes via <a class="el" href="struct_v_x_iinet_interface.html#o5">Read( )</a>, the implementation should return VXIinet_RESULT_END_OF_STREAM with nread = 20. If the client component then (incorrectly) requests 50 more bytes via <a class="el" href="struct_v_x_iinet_interface.html#o5">Read( )</a>, return VXIinet_RESULT_END_OF_STREAM again with nread = 0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>[OUT] Buffer that will receive data from the stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buflen</em>&nbsp;</td><td>[IN] Length of buffer, in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nread</em>&nbsp;</td><td>[OUT] Number of bytes actual read, may be less then buflen if the end of the stream was found, or if using non-blocking I/O and there is currently no more data available to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>[IN] Handle to the stream to read from</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIinet_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o7" doxytag="VXIinetInterface::SetCookieJar"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(* <a class="el" href="struct_v_x_iinet_interface.html#o7">VXIinetInterface::SetCookieJar</a>)(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, const VXIVector *jar)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the cookie jar. 
<p>
The cookie jar is used to provide cookies and store cookies during future VXIinet <a class="el" href="struct_v_x_iinet_interface.html#o2">Prefetch( )</a> and <a class="el" href="struct_v_x_iinet_interface.html#o3">Open( )</a> operations. Expired cookies within the jar will not be used. Each time this is called the prior cookie jar is discarded, the caller is responsible for persistent storage of the cookie jar if desired. See <a class="el" href="struct_v_x_iinet_interface.html#o8">GetCookieJar( )</a> for details.<p>
If <a class="el" href="struct_v_x_iinet_interface.html#o7">SetCookieJar( )</a> is never called, or if it is called with a NULL jar, the VXIinet implementation will refuse to accept cookies for fetches.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>jar</em>&nbsp;</td><td>[IN] Cookie jar, specified as a VXIVector (see the description of the cookie jar structure above). Pass NULL to refuse all cookies. Pass an empty VXIVector to accept new cookies starting with an empty jar. Pass a non-empty VXIVector as returned by <a class="el" href="struct_v_x_iinet_interface.html#o8">GetCookieJar( )</a> to implement persist cookies across multiple user sessions (telephone calls).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIinet_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o6" doxytag="VXIinetInterface::Write"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iinet.html#ga60">VXIinetResult</a>(* <a class="el" href="struct_v_x_iinet_interface.html#o6">VXIinetInterface::Write</a>)(struct <a class="el" href="struct_v_x_iinet_interface.html">VXIinetInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga1">VXIbyte</a> *buffer, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> buflen, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> *nwritten, VXIinetStream *stream)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write to a stream. 
<p>
This may or not block, as determined by the flags used when opening the stream. When in non-blocking mode, partial writes may occur instead of blocking, or an VXIinet_RESULT_WOULD_BLOCK error is returned if no data could be written at all.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>[OUT] Buffer of data to write to the stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buflen</em>&nbsp;</td><td>[IN] Number of bytes to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nwritten</em>&nbsp;</td><td>[OUT] Number of bytes actual written, may be less then buflen if an error is returned, or if using non-blocking I/O and the write operation would block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>[IN] Handle to the stream to write to</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIinet_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_v_x_iinet_8h.html">VXIinet.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jun 1 12:50:19 2005 for OpenVXI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
