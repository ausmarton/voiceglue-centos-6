<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenVXI: VXIcacheInterface Implementation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>VXIcacheInterface Implementation</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
SBcache interface, and implementation of <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> which permits writing arbitrary data into the cache with a client supplied key name, then retrieving that data from the cache one or more times by reading against that key name. 
<p>
Normally the cache implementation can choose to discard the data between the write and the read when necessary (due to running out of cache space, etc.), but it is also possible for clients to lock data in the cache to support built-in grammars and other data that is explicitly provisioned by system administrators and thus must not be removed unless by explicit system administrator command. <p>
See <a class="el" href="_v_x_icache_8h.html">VXIcache.h</a> for additional details.<p>
This implementation currently does NOT factor in CACHE_CREATION_COST when determining how to clean up the cache, and all caching is done on disk resulting in CACHE_FLAG_LOCK_MEMORY being treated as CACHE_FLAG_LOCK. In addition, CACHE_FLAG_NONBLOCKING_IO is ignored, disk I/O is done in a blocking manner (usually undetectable by clients since local disks are used). Long key names are handled using MD5 digests as described as a potential implementation choice in <a class="el" href="_v_x_icache_8h.html">VXIcache.h</a>.<p>
There is one cache interface per thread/line. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">*SBCACHE_API <a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_bcache.html#ga0">SBcacheInit</a> (<a class="el" href="struct_v_x_ilog_interface.html">VXIlogInterface</a> *log, const <a class="el" href="group___v_x_itypes.html#ga4">VXIunsigned</a> diagLogBase, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *cacheDir, const int cacheSizeMB, const int entryMaxSizeMB, const int entryExpTimeSec, <a class="el" href="group___v_x_itypes.html#ga0">VXIbool</a> unlockEntries, const int cacheLowWaterMB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global platform initialization of SBcache.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SBCACHE_API <a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_bcache.html#ga1">SBcacheShutDown</a> (<a class="el" href="struct_v_x_ilog_interface.html">VXIlogInterface</a> *log)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global platform shutdown of SBcache.  <a href="#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SBCACHE_API <a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_bcache.html#ga2">SBcacheCreateResource</a> (<a class="el" href="struct_v_x_ilog_interface.html">VXIlogInterface</a> *log, <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> **cache)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new cache service handle.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SBCACHE_API <a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_bcache.html#ga3">SBcacheDestroyResource</a> (<a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> **cache)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the interface and free internal resources.  <a href="#ga3"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga2" doxytag="SBcache.h::SBcacheCreateResource"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">SBCACHE_API <a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a> SBcacheCreateResource           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_v_x_ilog_interface.html">VXIlogInterface</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>log</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>cache</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new cache service handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>log</em>&nbsp;</td><td>[IN] VXI Logging interface used for error/diagnostic logging, must remain a valid pointer throughout the lifetime of the resource (until <a class="el" href="group___s_bcache.html#ga3">SBcacheDestroyResource()</a> is called) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cache</em>&nbsp;</td><td>[IN/OUT] Will hold the created cache resource.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIcache_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="SBcache.h::SBcacheDestroyResource"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">SBCACHE_API <a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a> SBcacheDestroyResource           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cache</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy the interface and free internal resources. 
<p>
Once this is called, the logging interface passed to <a class="el" href="group___s_bcache.html#ga2">SBcacheCreateResource( )</a> may be released as well.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cache</em>&nbsp;</td><td>[IN/OUT] The cache resource created by <a class="el" href="group___s_bcache.html#ga2">SBcacheCreateResource()</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIcache_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga0" doxytag="SBcache.h::SBcacheInit"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">* SBCACHE_API <a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a> SBcacheInit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_v_x_ilog_interface.html">VXIlogInterface</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>log</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="group___v_x_itypes.html#ga4">VXIunsigned</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>diagLogBase</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>cacheDir</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>cacheSizeMB</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>entryMaxSizeMB</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>entryExpTimeSec</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group___v_x_itypes.html#ga0">VXIbool</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>unlockEntries</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>cacheLowWaterMB</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Global platform initialization of SBcache. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>log</em>&nbsp;</td><td>VXI Logging interface used for error/diagnostic logging, only used for the duration of this function call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cacheDir</em>&nbsp;</td><td>Cache directory name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cacheSizeMB</em>&nbsp;</td><td>Maximum size of the data in the cache directory, in megabytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>entryMaxSizeMB</em>&nbsp;</td><td>Maximum size of any individual cache entry, in megabytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>entryExpTimeSec</em>&nbsp;</td><td>Maximum amount of time any individual cache entry will remain in the cache, in seconds </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>unlockEntries</em>&nbsp;</td><td>TRUE to unlock locked entries on startup (from using CACHE_FLAG_LOCK and CACHE_FLAG_LOCK_MEMORY), FALSE to leave them locked. In most cases it is best to pass TRUE with the platform re-adding locked entries at startup in order to avoid having obsolete locked entries fill up the cache. However, for some multi-process oriented integrations it may be necessary to pass FALSE and do this cleanup in some other way.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIcache_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="SBcache.h::SBcacheShutDown"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">SBCACHE_API <a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a> SBcacheShutDown           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_v_x_ilog_interface.html">VXIlogInterface</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>log</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Global platform shutdown of SBcache. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>log</em>&nbsp;</td><td>VXI Logging interface used for error/diagnostic logging, only used for the duration of this function call</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIcache_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jun 1 12:50:19 2005 for OpenVXI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
