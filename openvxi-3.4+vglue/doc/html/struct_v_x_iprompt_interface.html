<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenVXI: VXIpromptInterface Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>VXIpromptInterface Struct Reference<br>
<small>
[<a class="el" href="group___v_x_iprompt.html">Prompt Interface</a>]</small>
</h1><code>#include &lt;VXIprompt.h&gt;</code>
<p>
<a href="struct_v_x_iprompt_interface-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Abstract interface for Prompting functionality. 
<p>
Prompts are represented as a series of SSML documents.<p>
The Prompt interface the handles prefetching, caching, and streaming audio as required to provide good response times and low CPU and network overhead. <p>
There is one prompt interface per thread/line. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iprompt_interface.html#o0">GetVersion</a> )(void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the VXI interface version implemented.  <a href="#o0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iprompt_interface.html#o1">GetImplementationName</a> )(void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of the implementation.  <a href="#o1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iprompt_interface.html#o2">BeginSession</a> )(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis, VXIMap *args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset for a new session.  <a href="#o2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iprompt_interface.html#o3">EndSession</a> )(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis, VXIMap *args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs cleanup at the end of a call session.  <a href="#o3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iprompt_interface.html#o4">Play</a> )(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start playing queued segments (non-blocking).  <a href="#o4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iprompt_interface.html#o5">PlayFiller</a> )(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *type, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *src, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *text, const VXIMap *properties, <a class="el" href="group___v_x_itypes.html#ga6">VXIlong</a> minPlayMsec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queues and possibly starts the special play of a filler segment, non-blocking.  <a href="#o5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iprompt_interface.html#o6">Prefetch</a> )(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *type, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *src, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *text, const VXIMap *properties)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prefetch a segment (non-blocking).  <a href="#o6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iprompt_interface.html#o7">Queue</a> )(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *type, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *src, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *text, const VXIMap *properties)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue a segment for playing (non-blocking).  <a href="#o7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_iprompt_interface.html#o8">Wait</a> )(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis, <a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a> *playResult)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait until all played segments finish playing, blocking.  <a href="#o8"></a><br></td></tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="o2" doxytag="VXIpromptInterface::BeginSession"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(* <a class="el" href="struct_v_x_iprompt_interface.html#o2">VXIpromptInterface::BeginSession</a>)(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis, VXIMap *args)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset for a new session. 
<p>
This must be called for each new session, allowing for call specific handling to occur. For some implementations, this can be a no-op. For others runtime binding of resources or other call start specific handling may be done on this call.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td><b>[IN]</b> Implementation defined input and output arguments for the new session</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIprompt_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o3" doxytag="VXIpromptInterface::EndSession"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(* <a class="el" href="struct_v_x_iprompt_interface.html#o3">VXIpromptInterface::EndSession</a>)(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis, VXIMap *args)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs cleanup at the end of a call session. 
<p>
This must be called at the termination of a call, allowing for call specific termination to occur. For some implementations, this can be a no-op. For others runtime resources may be released or other adaptation may be completed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td><b>[IN]</b> Implementation defined input and output arguments for ending the session</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIprompt_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o1" doxytag="VXIpromptInterface::GetImplementationName"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a>*(* <a class="el" href="struct_v_x_iprompt_interface.html#o1">VXIpromptInterface::GetImplementationName</a>)(void)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the name of the implementation. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Implementation defined string that must be different from all other implementations. The recommended name is one where the interface name is prefixed by the implementator's Internet address in reverse order, such as com.xyz.rec for VXIrec from xyz.com. This is similar to how VoiceXML 1.0 recommends defining application specific error types. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o0" doxytag="VXIpromptInterface::GetVersion"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a>(* <a class="el" href="struct_v_x_iprompt_interface.html#o0">VXIpromptInterface::GetVersion</a>)(void)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the VXI interface version implemented. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>VXIint32 for the version number. The high high word is the major version number, the low word is the minor version number, using the native CPU/OS byte order. The current version is VXI_CURRENT_VERSION as defined in <a class="el" href="_v_x_itypes_8h.html">VXItypes.h</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o4" doxytag="VXIpromptInterface::Play"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(* <a class="el" href="struct_v_x_iprompt_interface.html#o4">VXIpromptInterface::Play</a>)(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start playing queued segments (non-blocking). 
<p>
Segments queued after this is called will not be played until this is called again. It is possible errors may occur after this function has returned: <a class="el" href="struct_v_x_iprompt_interface.html#o8">Wait()</a> will return the appropriate error if one occurred.<p>
Note that this stops the current <a class="el" href="struct_v_x_iprompt_interface.html#o5">PlayFiller()</a> operation although possibly after some delay, see <a class="el" href="struct_v_x_iprompt_interface.html#o5">PlayFiller()</a> for more information.<p>
<dl compact><dt><b>Returns:</b></dt><dd>VXIprompt_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o5" doxytag="VXIpromptInterface::PlayFiller"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(* <a class="el" href="struct_v_x_iprompt_interface.html#o5">VXIpromptInterface::PlayFiller</a>)(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *type, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *src, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *text, const VXIMap *properties, <a class="el" href="group___v_x_itypes.html#ga6">VXIlong</a> minPlayMsec)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Queues and possibly starts the special play of a filler segment, non-blocking. 
<p>
This plays a standard segment in a special manner in order to satisfy "filler" needs. A typical example is the VoiceXML fetchaudio attribute, used to specify filler audio that gets played while a document fetch is being performed and then interrupted once the fetch completes.<p>
The filler segment is played to the caller once all active <a class="el" href="struct_v_x_iprompt_interface.html#o4">Play()</a> operations, if any, have completed. If <a class="el" href="struct_v_x_iprompt_interface.html#o4">Play()</a>, <a class="el" href="struct_v_x_iprompt_interface.html#o8">Wait()</a>, or <a class="el" href="struct_v_x_iprompt_interface.html#o5">PlayFiller()</a> is called before the filler segment starts playing it is cancelled and never played. If one of those functions is instead called after the filler segment starts playing, the filler segment is stopped once the minimum playback duration expires.<p>
NOTE: this does not trigger the play of segments that have been queued but not yet played via <a class="el" href="struct_v_x_iprompt_interface.html#o4">Play()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td><b>[IN]</b> Type of segment, either a MIME content type, a sayas class name, or NULL to automatically detect a MIME content type (only valid when src is non-NULL). The supported MIME content types and sayas class names are implementation dependant. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td><b>deprecated</b> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td><b>[IN]</b> Text (possibly with markup) to play via TTS or sayas classes, pass NULL when src is non-NULL. The format of text for TTS playback may be W3C SSML (type set to VXI_MIME_SSML) or simple wchar_t text (type set to VXI_MIME_UNICODE_TEXT). The implementation may also support other formats. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td><b>[IN]</b> Properties to control the fetch, queue, and play, as specified above. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minPlayMsec</em>&nbsp;</td><td><b>[IN]</b> Minimum playback duration for the filler prompt once it starts playing, in milliseconds. This is used to "lock in" a play so that no less then this amount of audio is heard by the caller once it starts playing, avoiding confusion from audio that is played for an extremely brief duration and then cut off. Note that the filler prompt may never be played at all, however, if cancelled before it ever starts playing as described above.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIprompt_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o6" doxytag="VXIpromptInterface::Prefetch"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(* <a class="el" href="struct_v_x_iprompt_interface.html#o6">VXIpromptInterface::Prefetch</a>)(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *type, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *src,const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *text, const VXIMap *properties)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prefetch a segment (non-blocking). 
<p>
This fetches the segment in the background, since this returns before the fetch proceeds failures during the fetch will not be reported (invalid URI, missing file, etc.). This may be called prior to <a class="el" href="struct_v_x_iprompt_interface.html#o7">Queue()</a> (possibily multiple times with increasing VXIinet prefetch priorities as the time for playback gets closer).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td><b>[IN]</b> Type of segment. Currently, the only type used is VXI_MIME_SSML. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td><b>deprecated</b> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td><b>[IN]</b> The prompt text. Currently, the only text format used is SSML. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td><b>[IN]</b> Properties to control the fetch, queue, and play, as specified above. May be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIprompt_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o7" doxytag="VXIpromptInterface::Queue"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(* <a class="el" href="struct_v_x_iprompt_interface.html#o7">VXIpromptInterface::Queue</a>)(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *type, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *src,const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *text, const VXIMap *properties)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Queue a segment for playing (non-blocking). 
<p>
The segment does not start playing until the <a class="el" href="struct_v_x_iprompt_interface.html#o4">Play()</a> method is called.<p>
VoiceXML allows audio collected during the &lt;record&gt; element to be played in the middle of SSML documents. These recordings are passed by VXI to the VXIprompt implementation inside the properties VXIMap. The PROMPT_AUDIO_REFS points to a second VXIMap containing pairs of identifiers (VXIStrings) and their associated recording (VXIContent).<p>
Within the SSML document, the audio recording is replaced by a mark element whose 'name' attribute is a key inside the PROMPT_AUDIO_REFS map. i.e., Use the mark name as the key to access the VXIContent in the PROMPT_AUDIO_REFS map. The mark name for audio content will be prefixed with PROMPT_AUDIO_REFS_SCHEME so that it can be distinguished from other &lt;mark&gt; elements.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td><b>[IN]</b> Type of segment. Currently, the only type used is VXI_MIME_SSML. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td><b>deprecated</b> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td><b>[IN]</b> The prompt text. Currently, the only text format used is SSML. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td><b>[IN]</b> Properties to control the fetch, queue, and play, as specified above. May be NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIprompt_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o8" doxytag="VXIpromptInterface::Wait"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a>(* <a class="el" href="struct_v_x_iprompt_interface.html#o8">VXIpromptInterface::Wait</a>)(struct <a class="el" href="struct_v_x_iprompt_interface.html">VXIpromptInterface</a> *pThis, <a class="el" href="group___v_x_iprompt.html#ga5">VXIpromptResult</a> *playResult)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait until all played segments finish playing, blocking. 
<p>
Note that this stops the current <a class="el" href="struct_v_x_iprompt_interface.html#o5">PlayFiller()</a> operation although possibly after some delay, see <a class="el" href="struct_v_x_iprompt_interface.html#o5">PlayFiller()</a> for more information.<p>
If Wait is called, and no audio is playing, this function should not block.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>playResult</em>&nbsp;</td><td><b>[OUT]</b> Most severe error code resulting from a <a class="el" href="struct_v_x_iprompt_interface.html#o4">Play()</a> operation since the last <a class="el" href="struct_v_x_iprompt_interface.html#o8">Wait()</a> call, since <a class="el" href="struct_v_x_iprompt_interface.html#o4">Play()</a> is asynchronous, errors may have occurred after one or more calls to it have returned. Note that this ignores any errors resulting from <a class="el" href="struct_v_x_iprompt_interface.html#o5">PlayFiller()</a> operations.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIprompt_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_v_x_iprompt_8h.html">VXIprompt.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jun 1 12:50:19 2005 for OpenVXI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
