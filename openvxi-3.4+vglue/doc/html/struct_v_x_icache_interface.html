<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenVXI: VXIcacheInterface Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>VXIcacheInterface Struct Reference<br>
<small>
[<a class="el" href="group___v_x_icache.html">Cache Interface</a>]</small>
</h1><code>#include &lt;VXIcache.h&gt;</code>
<p>
<a href="struct_v_x_icache_interface-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Abstract interface for accessing caching functionality. 
<p>
Permits writing arbitrary data into the cache with a client supplied key name, then retrieving that data from the cache one or more times by reading against that key name. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_icache_interface.html#o0">GetVersion</a> )(void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the VXI interface version implemented.  <a href="#o0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_icache_interface.html#o1">GetImplementationName</a> )(void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of the implementation.  <a href="#o1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_icache_interface.html#o2">Open</a> )(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *moduleName, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *key, <a class="el" href="group___v_x_icache.html#ga18">VXIcacheOpenMode</a> mode, <a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a> flags, const VXIMap *properties, VXIMap *streamInfo, VXIcacheStream **stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a stream for reading or writing given a wide character key.  <a href="#o2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_icache_interface.html#o3">Close</a> )(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, VXIcacheStream **stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a previously opened stream.  <a href="#o3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_icache_interface.html#o4">Unlock</a> )(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock an entry that was previously locked into the cache given a wide character key.  <a href="#o4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_icache_interface.html#o5">Read</a> )(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, <a class="el" href="group___v_x_itypes.html#ga1">VXIbyte</a> *buffer, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> buflen, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> *nread, VXIcacheStream *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from a stream.  <a href="#o5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_icache_interface.html#o6">Write</a> )(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga1">VXIbyte</a> *buffer, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> buflen, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> *nwritten, VXIcacheStream *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a stream.  <a href="#o6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_icache_interface.html#o7">OpenEx</a> )(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *moduleName, const <a class="el" href="group___v_x_itypes.html#ga1">VXIbyte</a> *key, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> keySizeBytes, <a class="el" href="group___v_x_icache.html#ga18">VXIcacheOpenMode</a> mode, <a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a> flags, const VXIMap *properties, VXIMap *streamInfo, VXIcacheStream **stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a stream for reading or writing given a binary key.  <a href="#o7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_icache_interface.html#o8">CloseEx</a> )(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, <a class="el" href="group___v_x_itypes.html#ga0">VXIbool</a> keepEntry, VXIcacheStream **stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a previously opened stream.  <a href="#o8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_x_icache_interface.html#o9">UnlockEx</a> )(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga1">VXIbyte</a> *key, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> keySizeBytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock an entry that was previously locked into the cache given a binary key.  <a href="#o9"></a><br></td></tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="o3" doxytag="VXIcacheInterface::Close"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(* <a class="el" href="struct_v_x_icache_interface.html#o3">VXIcacheInterface::Close</a>)(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, VXIcacheStream **stream)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close a previously opened stream. 
<p>
NOTE: <a class="el" href="struct_v_x_icache_interface.html#o8">CloseEx( )</a> is the same but supports invalidating the entry<p>
Close a previously opened stream. If Close is called on a NULL stream or a previously closed stream an error will be returned<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>[IN/OUT] Stream to close, set to NULL on success</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIcache_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o8" doxytag="VXIcacheInterface::CloseEx"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(* <a class="el" href="struct_v_x_icache_interface.html#o8">VXIcacheInterface::CloseEx</a>)(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, <a class="el" href="group___v_x_itypes.html#ga0">VXIbool</a> keepEntry, VXIcacheStream **stream)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close a previously opened stream. 
<p>
NOTE: Same as <a class="el" href="struct_v_x_icache_interface.html#o3">Close( )</a> but supports invalidating the entry. This is only available as of version 1.1 of the VXIcacheInterface, use <a class="el" href="group___v_x_icache.html#ga14">CACHE_CLOSEEX_SUPPORTED( )</a> to determine availability.<p>
Close a previously opened stream. If Close is called on a NULL stream or a previously closed stream an error will be returned<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keepEntry</em>&nbsp;</td><td>[IN] TRUE to indiate the write was a success and the cache entry should be retained, FALSE to indicate the write failed (typically due to a data source read unexpectedly failing) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>[IN/OUT] Stream to close, set to NULL on success</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIcache_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o1" doxytag="VXIcacheInterface::GetImplementationName"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a>*(* <a class="el" href="struct_v_x_icache_interface.html#o1">VXIcacheInterface::GetImplementationName</a>)(void)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the name of the implementation. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Implementation defined string that must be different from all other implementations. The recommended name is one where the interface name is prefixed by the implementator's Internet address in reverse order, such as com.xyz.rec for VXIrec from xyz.com. This is similar to how VoiceXML 1.0 recommends defining application specific error types. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o0" doxytag="VXIcacheInterface::GetVersion"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a>(* <a class="el" href="struct_v_x_icache_interface.html#o0">VXIcacheInterface::GetVersion</a>)(void)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the VXI interface version implemented. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>VXIint32 for the version number. The high high word is the major version number, the low word is the minor version number, using the native CPU/OS byte order. The current version is VXI_CURRENT_VERSION as defined in <a class="el" href="_v_x_itypes_8h.html">VXItypes.h</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o2" doxytag="VXIcacheInterface::Open"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(* <a class="el" href="struct_v_x_icache_interface.html#o2">VXIcacheInterface::Open</a>)(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *moduleName, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *key, <a class="el" href="group___v_x_icache.html#ga18">VXIcacheOpenMode</a> mode, <a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a> flags, const VXIMap *properties, VXIMap *streamInfo, VXIcacheStream **stream)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open a stream for reading or writing given a wide character key. 
<p>
NOTE: <a class="el" href="struct_v_x_icache_interface.html#o7">OpenEx( )</a> is the same but supports binary keys<p>
If the cache entry is currently in use and a stream cannot be returned because this use locks the entry, Open should return VXIcache_RESULT_ENTRY_LOCKED. <p>
The behavior of opening a cache entry for reading during a write operation is implementation defined. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>moduleName</em>&nbsp;</td><td>[IN] Name of the software module that is writing or reading the data. See the top of <a class="el" href="_v_x_ilog_8h.html">VXIlog.h</a> for moduleName allocation rules. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>[IN] Key name of the data to access, NULL terminated VXIchar based string that may be of an arbitrary length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>[IN] Mode to open the data with, a CACHE_MODE value as defined above </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>[IN] Flags to control the open: CACHE_FLAG_LOCK, lock retrieved data in the cache so it is not flushed (although may be flushed from the memory cache to the disk cache) CACHE_FLAG_LOCK_MEMORY, lock retrieved data in the memory cache so it is not flushed (not even to the disk cache), note that some implementations may ignore this and simply treat this as CACHE_FLAG_LOCK. CACHE_FLAG_NONBLOCKING_IO, non-blocking reads and writes, although the open and close is still blocking </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>[IN] Properties to control the open, as listed above. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streamInfo</em>&nbsp;</td><td>[OUT] (Optional, pass NULL if not required.) Map that will be populated with information about the stream, the CACHE_INFO_[...] keys listed above are mandatory with the implementation possibly setting other keys. This may not be populated on an open for WRITE since that is creating a new file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>[OUT] Handle to the opened stream</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIcache_RESULT_SUCCESS on success <p>
VXIcache_RESULT_ENTRY_LOCKED if the entry is in used and cannot be returned. Returned if a writer has the entry open. <p>
VXIcache_RESULT_NULL_STREAM if the stream that was passed in or the interface is NULL </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o7" doxytag="VXIcacheInterface::OpenEx"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(* <a class="el" href="struct_v_x_icache_interface.html#o7">VXIcacheInterface::OpenEx</a>)(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *moduleName, const <a class="el" href="group___v_x_itypes.html#ga1">VXIbyte</a> *key, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> keySizeBytes, <a class="el" href="group___v_x_icache.html#ga18">VXIcacheOpenMode</a> mode, <a class="el" href="group___v_x_itypes.html#ga5">VXIint32</a> flags, const VXIMap *properties, VXIMap *streamInfo, VXIcacheStream **stream)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open a stream for reading or writing given a binary key. 
<p>
NOTE: Same as <a class="el" href="struct_v_x_icache_interface.html#o2">Open( )</a> but supports binary keys. This is only available as of version 1.1 of the VXIcacheInterface, use <a class="el" href="group___v_x_icache.html#ga13">CACHE_OPENEX_SUPPORTED( )</a> to determine availability.<p>
If the cache entry is currently in use and a stream cannot be returned because this use locks the entry, Open should return VXIcache_RESULT_ENTRY_LOCKED. <p>
The behavior of opening a cache entry for reading during a write operation is implementation defined. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>moduleName</em>&nbsp;</td><td>[IN] Name of the software module that is writing or reading the data. See the top of <a class="el" href="_v_x_ilog_8h.html">VXIlog.h</a> for moduleName allocation rules. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>[IN] Key name of the data to access, binary data (raw bytes) of an arbitrary length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keySizeBytes</em>&nbsp;</td><td>[IN] Size of the key name in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>[IN] Mode to open the data with, a CACHE_MODE value as defined above </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>[IN] Flags to control the open: CACHE_FLAG_LOCK, lock retrieved data in the cache so it is not flushed (although may be flushed from the memory cache to the disk cache) CACHE_FLAG_LOCK_MEMORY, lock retrieved data in the memory cache so it is not flushed (not even to the disk cache), note that some implementations may ignore this and simply treat this as CACHE_FLAG_LOCK. CACHE_FLAG_NONBLOCKING_IO, non-blocking reads and writes, although the open and close is still blocking </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>[IN] Properties to control the open, as listed above. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streamInfo</em>&nbsp;</td><td>[OUT] (Optional, pass NULL if not required.) Map that will be populated with information about the stream, the CACHE_INFO_[...] keys listed above are mandatory with the implementation possibly setting other keys. This may not be populated on an open for WRITE since that is creating a new file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>[OUT] Handle to the opened stream</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIcache_RESULT_SUCCESS on success <p>
VXIcache_RESULT_ENTRY_LOCKED if the entry is in used and cannot be returned. Returned if a writer has the entry open. <p>
VXIcache_RESULT_NULL_STREAM if the stream that was passed in or the interface is NULL </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o5" doxytag="VXIcacheInterface::Read"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(* <a class="el" href="struct_v_x_icache_interface.html#o5">VXIcacheInterface::Read</a>)(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, <a class="el" href="group___v_x_itypes.html#ga1">VXIbyte</a> *buffer, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> buflen, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> *nread, VXIcacheStream *stream)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read from a stream. 
<p>
This may or not block, as determined by the flags used when opening the stream. When in non-blocking mode, partial buffers may be returned instead of blocking, or an VXIcache_RESULT_WOULD_BLOCK error is returned if no data is available at all.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>[OUT] Buffer that will receive data from the stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buflen</em>&nbsp;</td><td>[IN] Length of buffer, in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nread</em>&nbsp;</td><td>[OUT] Number of bytes actual read, may be less then buflen if the end of the stream was found, or if using non-blocking I/O and there is currently no more data available to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>[IN] Handle to the stream to read from</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIcache_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o4" doxytag="VXIcacheInterface::Unlock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(* <a class="el" href="struct_v_x_icache_interface.html#o4">VXIcacheInterface::Unlock</a>)(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga2">VXIchar</a> *key)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock an entry that was previously locked into the cache given a wide character key. 
<p>
NOTE: <a class="el" href="struct_v_x_icache_interface.html#o9">UnlockEx( )</a> is the same but supports binary keys<p>
This releases a cache lock on the indicated data. Note that it is up to the implementation to decide when to flush the data from the cache, it may choose to do so immediately or may do so at a later time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>[IN] Key name of the data to access, NULL terminated VXIchar based string that may be of an arbitrary length</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIcache_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o9" doxytag="VXIcacheInterface::UnlockEx"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(* <a class="el" href="struct_v_x_icache_interface.html#o9">VXIcacheInterface::UnlockEx</a>)(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga1">VXIbyte</a> *key, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> keySizeBytes)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock an entry that was previously locked into the cache given a binary key. 
<p>
NOTE: Same as <a class="el" href="struct_v_x_icache_interface.html#o4">Unlock( )</a> but supports binary keys. This is only available as of version 1.1 of the VXIcacheInterface, use <a class="el" href="group___v_x_icache.html#ga15">CACHE_UNLOCKEX_SUPPORTED( )</a> to determine availability.<p>
This releases a cache lock on the indicated data. Note that it is up to the implementation to decide when to flush the data from the cache, it may choose to do so immediately or may do so at a later time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>[IN] Key name of the data to access, binary data (raw bytes) of an arbitrary length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keySizeBytes</em>&nbsp;</td><td>[IN] Size of the key name in bytes</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIcache_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o6" doxytag="VXIcacheInterface::Write"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group___v_x_icache.html#ga19">VXIcacheResult</a>(* <a class="el" href="struct_v_x_icache_interface.html#o6">VXIcacheInterface::Write</a>)(struct <a class="el" href="struct_v_x_icache_interface.html">VXIcacheInterface</a> *pThis, const <a class="el" href="group___v_x_itypes.html#ga1">VXIbyte</a> *buffer, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> buflen, <a class="el" href="group___v_x_itypes.html#ga7">VXIulong</a> *nwritten, VXIcacheStream *stream)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write to a stream. 
<p>
This may or not block, as determined by the flags used when opening the stream. When in non-blocking mode, partial writes may occur instead of blocking, or an VXIcache_RESULT_WOULD_BLOCK error is returned if no data could be written at all.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>[OUT] Buffer of data to write to the stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buflen</em>&nbsp;</td><td>[IN] Number of bytes to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nread</em>&nbsp;</td><td>[OUT] Number of bytes actual written, may be less then buflen if an error is returned, or if using non-blocking I/O and the write operation would block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>[IN] Handle to the stream to write to</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>VXIcache_RESULT_SUCCESS on success </dd></dl>
    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_v_x_icache_8h.html">VXIcache.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jun 1 12:50:19 2005 for OpenVXI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
