.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Cam::Scom 3"
.TH Cam::Scom 3 "2012-03-22" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Cam::Scom \- Supercharged asynchronous inter\-process COMmunication
.SH "VERSION"
.IX Header "VERSION"
Version 0.08
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Cam::Scom provides two levels of functionality.
.PP
Its high level functions provide advanced means of interacting with
executables.  They allow execution with feeds to stdin and capture of
stdout and stderr.  The high level functions are:
.PP
.Vb 4
\&    scomrun (@command)
\&    scomrunin ($input, @command)
\&    scomrun_opt ($uid, $gid, $detach, @command)
\&    scomrunin_opt ($uid, $gid, $detach, $input, @command)
.Ve
.PP
Its low level functions provide asynchronous manipulation of reads and
writes on multiple filehandles within a single thread and process.  All
other functions are low level functions.  They are used in an object\-
oriented fashion.
.PP
Here is  a  code fragment that  performs the equivalent  of the  shell
command \*(L"man perl | col \-b\*(R":
.PP
.Vb 2
\&        $scom\->exec (["MANIN<1?"], 0, "man", "perl");
\&        $scom\->exec (["MANIN>0!"], 0, "col", "\-b");
.Ve
.SS "\s-1LOW\s0 \s-1LEVEL\s0 \s-1FUNCTION\s0 \s-1OVERVIEW\s0"
.IX Subsection "LOW LEVEL FUNCTION OVERVIEW"
At a low level, Scom provides event-driven inter-process communication
over file descriptors.  The supported types of descriptors are pipe
streams, socket streams, socket servers, and datagrams.  Scom supports
streams both to and from other executing processes without danger of
deadlock.  Deadlock is avoided by using non-blocking I/O and buffering
all blocked reads and writes for later retry.  It is necessary to have
an event processing loop that regularly calls \fIgetevents()\fR to maintain
data flow.  Typically \fIgetevents()\fR is called in the main dispatching
loop to provide a means of blocking until the next I/O event occurs.
.PP
The Scom package will only manipulate file descriptors that have been
registered with it.  They may be created outside of Scom and then
registered, or they may be created by methods provided by Scom.
Provided methods include \fIexec()\fR for creating and registering pipes to
and from exec'd processes, \fIconnect()\fR for creating and registering \s-1TCP\s0
client sockets, \fIlisten()\fR for creating and registering \s-1TCP\s0 server
sockets, and \fIdatagram()\fR for creating and registering \s-1UDP\s0 sockets.
Method \fIregister()\fR will register any previously opened file descriptors.
Previously opened filehandles must support fileno, close, and
the following additional methods depending on their type:
.PP
.Vb 3
\&  streams:           read, write  (filehandles or file descriptors)
\&  datagrams:         recv, send   (requires perl filehandles)
\&  socket listeners:  accept       (requires perl filehandles)
.Ve
.PP
Finally, \fIexpect()\fR implements all of the functionality of the
tcl-based expect language, with the exception of using actual pty's.
.PP
Filehandles registered with Scom may be either old-style perl
filehandles or FileHandle or IO::Handle objects or Unix file
descriptor numbers.  If old-style perl filehandles are used, they are
always utilized as symbolic references, and are evaluated relative to
the Scom package.  This implies that it is usually best to include a
full package name with the name of a filehandle, such as:
.PP
.Vb 1
\&        $obj\->register ("main::READER<");
.Ve
.PP
Registered filehandles should not be manipulated outside of the Scom
routines.
.PP
Any number of Scom objects may be created, each with a different set
of registered filehandles.  Do not register a filehandle to
more than one Scom object.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "scomrun (@command)"
.IX Subsection "scomrun (@command)"
All of the functions scomrun, scomrunin, scomrun_opt,
and scomrunin_opt execute \f(CW@command\fR via perl's \fIexec()\fR, and return the
following array:
.PP
.Vb 1
\&        ($ok, $msg, $stdout_output, $stderr_output)
.Ve
.PP
where \f(CW$stdout_output\fR is all the output from the command's
stdout, and \f(CW$stderr_output\fR is all the output from the
command's stderr.  Also sets $?  to the exit status.  On error
it sets \f(CW$ok\fR to false, \f(CW$msg\fR to an error message, and other
results to undef.  The command is run in the parent's process
group.
.PP
The \f(CW$input\fR parameter to \fIscomrunin()\fR and \fIscomrunin_opt()\fR is fed
to \f(CW@command\fR's stdin.  \fIscomrun()\fR and \fIscomrun_opt()\fR inherit the
existing stdin.
.PP
For the *_opt versions, if either \f(CW$uid\fR or \f(CW$gid\fR are defined,
sets the corresponding uid = \f(CW$uid\fR and/or gid = \f(CW$gid\fR (both real
and effective) in the child process.  If \f(CW$detach\fR is true, the
command will have its own process group.
.PP
The \s-1SIGCHLD\s0 signal, if not set to the default behavior, will
be set to its default behavior before execution, and then
reset to its original value when done.  Note that this can
result in signal lossage unless handled correctly.
.PP
These functions will not return until the output pipes stderr
and stdout have closed, whether or not the process has exited.
This means that if the started process starts children that
inherit stdout and/or stderr, the functions will not return
until all such children (recursively) have either terminated
or closed their stdout & stderr descriptors.
.ie n .SS "scomrunin ($input, @command)"
.el .SS "scomrunin ($input, \f(CW@command\fP)"
.IX Subsection "scomrunin ($input, @command)"
See scomrun.
.ie n .SS "scomrun_opt ($uid, $gid, $detach, @command)"
.el .SS "scomrun_opt ($uid, \f(CW$gid\fP, \f(CW$detach\fP, \f(CW@command\fP)"
.IX Subsection "scomrun_opt ($uid, $gid, $detach, @command)"
See scomrun.
.ie n .SS "scomrunin_opt ($uid, $gid, $detach, $input, @command)"
.el .SS "scomrunin_opt ($uid, \f(CW$gid\fP, \f(CW$detach\fP, \f(CW$input\fP, \f(CW@command\fP)"
.IX Subsection "scomrunin_opt ($uid, $gid, $detach, $input, @command)"
See scomrun.
.SS "new"
.IX Subsection "new"
Returns a new, empty Scom object with no registered
filehandles on success.
On failure, returns a string describing the error.
Use \fIref()\fR to determine success on the result.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "\->register ($pipe [, $pipe ...])"
.el .SS "\->register ($pipe [, \f(CW$pipe\fP ...])"
.IX Subsection "->register ($pipe [, $pipe ...])"
.Vb 2
\&        Registers filehandles that are already opened.  The format for
\&        each $pipe element is either:
\&
\&                "<fhname><direction>[<exec>][<flags>]"
\&        or:
\&                [<FileHandle>, "<direction>[<exec>][<flags>]"]
\&
\&        where
\&            <fhname>    ::=     the filehandle symbolic name or descriptor
\&
\&            <FileHandle>::=     the FileHandle object or name or descriptor
\&
\&            <direction> ::=     ">" for write\-only streams,
\&                                "<" for read\-only streams,
\&                                "+" for read\-write stream (bidirectional),
\&                                "*" for sendto\-recvfrom (bidirectional).
\&
\&            <exec>      ::=     (Ignored by register, but used
\&                                by exec.  See exec.)
\&
\&            <flags>     ::=     flags indicating the setting of
\&                                close\-on\-unregister and the value
\&                                of the input record separator.
\&                                Has form:
\&
\&                                <no_close><close\-on\-exec><separator>
\&
\&                <no_close>      ::=     either "", indicating close\-on\-
\&                                        unregister, or "|", indicating
\&                                        no close\-on\-unregister.
\&
\&                <close\-on\-exec> ::=     either "", meaning don\*(Aqt set
\&                                        close\-on\-exec, or ".", meaning
\&                                        set close\-on\-exec.
\&
\&                <separator>     ::=     the input record separator
\&                                        for getevents (see below).
\&                                        If omitted, the separator
\&                                        will be "\en".  Otherwise,
\&                                        specify as ":<chars>" where
\&                                        <chars> is the (possibly empty)
\&                                        separator character sequence.
\&                                        Input record separators are only
\&                                        meaningful on stream types, and
\&                                        are ingnored on datagram sockets.
\&
\&        It is an error to register a filehandle first in one direction
\&        and subsequently in the other; both directions must be done at
\&        the same time.
\&
\&        Returns ($ok,  $msg) where  $ok is  true  on success, false on
\&        error.  On error, $msg will be set to an error message.
.Ve
.ie n .SS "\->unregister ($filehandle [, $filehandle ...])"
.el .SS "\->unregister ($filehandle [, \f(CW$filehandle\fP ...])"
.IX Subsection "->unregister ($filehandle [, $filehandle ...])"
Unregisters  the  specified   filehandles.    Unregistering  a
filehandle closes it, unless close-on-unregister was unset.
.ie n .SS "\->exec_opt (@$pipes, $uid, $gid, $detach, @command)"
.el .SS "\->exec_opt (@$pipes, \f(CW$uid\fP, \f(CW$gid\fP, \f(CW$detach\fP, \f(CW@command\fP)"
.IX Subsection "->exec_opt (@$pipes, $uid, $gid, $detach, @command)"
Runs \f(CW@command\fR via perl's \fIexec()\fR, and attaches input and output
pipes to it.  If \f(CW$detach\fR is true, the command will have its
own process group.  \f(CW$pipes\fR is a ref to an array of strings
defining the pipes to connect to \f(CW@command\fR.  The format for
each pipes element is as in register, except that <exec> is
required, and <direction> must be \*(L">\*(R" or \*(L"<\*(R".  <exec> is
defined as:
.PP
.Vb 1
\&            <exec>      ::=     <fd><use>
\&
\&            <fd>        ::=     the file descriptor number within
\&                                the exec\*(Aqd command to attach to.
\&
\&            <use>       ::=     either "", indicating that <fhname>
\&                                is to be created and registered,
\&                                or "?", indicating that <fhname> is to
\&                                be created but not registered (though
\&                                the close\-on\-exec flag is still valid),
\&                                or "!", indicating that <fhname> already
\&                                exists, and should be usurped by the
\&                                exec\*(Aqd command, and closed in this process.
.Ve
.PP
Both return ($pid, \f(CW$msg\fR), where \f(CW$pid\fR is the pid from the perl
\&\fIfork()\fR call, or 0 on error.  On error, \f(CW$msg\fR will be set to an
error message.
.PP
For the \fIexec_opt()\fR version, if either \f(CW$uid\fR or \f(CW$gid\fR are
defined, sets the corresponding uid = \f(CW$uid\fR and/or gid = \f(CW$gid\fR
(both real and effective) in the child process.
.PP
The descriptors passed to the exec'd process will have flags
as originally set by the system \fIpipe()\fR call (and thus are
blocking).
.ie n .SS "\->exec (@$pipes, $detach, @command)"
.el .SS "\->exec (@$pipes, \f(CW$detach\fP, \f(CW@command\fP)"
.IX Subsection "->exec (@$pipes, $detach, @command)"
Identical to exec_opt, except it does not change uid or gid
.ie n .SS "\->connect ($fh, $host, $port, $flags, $nonblocking)"
.el .SS "\->connect ($fh, \f(CW$host\fP, \f(CW$port\fP, \f(CW$flags\fP, \f(CW$nonblocking\fP)"
.IX Subsection "->connect ($fh, $host, $port, $flags, $nonblocking)"
Opens and registers a bidirectional filehandle \f(CW$fh\fR (must be a
name, not an object) that connects to \s-1TCP\s0 server \f(CW$port\fR at
\&\f(CW$host\fR.  Both \f(CW$host\fR and \f(CW$port\fR may be specified numerically or
by name.  If \f(CW$host\fR is the null string, the local host is used.
\&\f(CW$flags\fR is used as <flags> in register.  If \f(CW$nonblocking\fR is
true, will perform a nonblocking connect, and failure may only
be detected on subsequent events.  Returns ($ok, \f(CW$msg\fR) where
\&\f(CW$ok\fR is true on success, false on error.  On error, \f(CW$msg\fR will
be set to an error message.
.ie n .SS "\->listen ($fh, $port, $rcvname [, $addr]);"
.el .SS "\->listen ($fh, \f(CW$port\fP, \f(CW$rcvname\fP [, \f(CW$addr\fP]);"
.IX Subsection "->listen ($fh, $port, $rcvname [, $addr]);"
Opens and registers a read-only, close-on-exec filehandle \f(CW$fh\fR
(must be a name, not an object) that receives \s-1TCP\s0 connections
on port \f(CW$port\fR, which may be specified numerically or by name.
When new connections are accepted, getevents will return a new
filehandle name of the connection, and the address of the
connected host.  The new filehandle names will be \f(CW$rcvname\fR
appended by an integer.  The accepted filehandles are not
initially registered, but can be registered with register if desired.
If \f(CW$addr\fR is specified, listens only on that address (may be a
hostname or \*(L"x.x.x.x\*(R" format), if not specified, listens on all.
Returns ($ok, \f(CW$msg\fR) where \f(CW$msg\fR is true on
success, false on error.  On error, \f(CW$msg\fR will be set to an
error message.
.ie n .SS "\->datagram ($fh, $port, $flags)"
.el .SS "\->datagram ($fh, \f(CW$port\fP, \f(CW$flags\fP)"
.IX Subsection "->datagram ($fh, $port, $flags)"
Opens and registers a bidirectional filehandle \f(CW$fhname\fR (name,
not object) of type \*(L"*\*(R" (messaging) that sends and listens for
datagrams at \f(CW$port\fR.  \f(CW$port\fR may be specified numerically or by
name.  \f(CW$flags\fR is used as <flags> in &ipc'register.  Returns
($ok, \f(CW$msg\fR) where \f(CW$ok\fR is true on success, false on error.  On
error, \f(CW$msg\fR will be set to an error message.
.ie n .SS "\->getevents ($timeout [, $filehandle ...])"
.el .SS "\->getevents ($timeout [, \f(CW$filehandle\fP ...])"
.IX Subsection "->getevents ($timeout [, $filehandle ...])"
Reads and writes available data on all registered filehandles,
and looks for events on all registered filehandles specified
in the argument list (no specified filehandles means all
registered filehandles).  It appears to the caller to block
until one of the following occurs:
.PP
.Vb 2
\&            *   $timeout seconds have elapsed with no activity
\&                on any registered filehandles
\&
\&            *   no specified filehandles are readable or writable
\&
\&            *   an event was received on a specified filehandle, one of:
\&
\&                    \-   input was received from a specified stream filehandle
\&                        containing its separator
\&
\&                    \-   input was received from a specified stream filehandle
\&                        with a null separator
\&
\&                    \-   input was received from a specified datagram filehandle
\&
\&                    \-   error when reading or writing a specified filehandle
\&
\&                    \-   EOF or close on flush from/to a specified filehandle
.Ve
.PP
A \f(CW$timeout\fR of \-1 is considered infinite.
.PP
It returns a list of arrayrefs, or the empty list if no events
have occurred.  Each arrayref points to an array whose first
element is the filehandle being reported in the subsequent
array elements.  Subsequent array elements are either scalars,
in which case they are data received (for streaming
filehandles), or Cam::Scom::Event objects describing an event.
The Cam::Scom::Event objects must be referred to by typed
references (declare as \*(L"my Cam::Scom::Event \f(CW$foo\fR\*(R") and have
the following named fields:
.PP
.Vb 8
\&          $event\->{fh}      \-\- the filehandle object being reported
\&          $event\->{end}     \-\- true if this is a termination event
\&          $event\->{term}    \-\- termination code (if $event\->{end}) (see below)
\&          $event\->{data}    \-\- the data (for messaging, non\-server)(if ! "end")
\&          $event\->{port}    \-\- sender port number (for messaging)  (if ! "end")
\&                               new connect filehandle (for server) (if ! "end")
\&          $event\->{addr}    \-\- 4\-byte sender addr (for messaging)  (if ! "end")
\&                               4\-byte connect addr (for server)    (if ! "end")
.Ve
.PP
If the \*(L"end\*(R" field is true for a filehandle, then
close-on-flush, \s-1EOF\s0, or error has occurred, the filehandle has
been unregistered, and no more events will be reported for it.
A termination code of 0 indicates either \s-1EOF\s0 or
close-on-flush.  A positive, non\-0 termination code is the
errno reported by the failed read or write.  A negative
termination code has the following meanings:
.PP
.Vb 7
\&            \-1  \-\- the read or write buffer size was exceeded
\&                   and the filehandle\*(Aqs terminator was turned on.
\&            \-2  \-\- the read buffer size was exceeded, the filehandle\*(Aqs
\&                   terminator was turned on, there was a separator
\&                   defined, and the separator was not detected.
\&            \-3  \-\- the file descriptor became invalid, and could not
\&                   be select()\*(Aqed
.Ve
.PP
If the file is a stream and the filehandle's separator was
specified as non-null, data elements are broken after each
occurrence of the separator, which is retained in the data.
.ie n .SS "\->write ($filehandle, $data [, $port, $addr [, $addr ...]])"
.el .SS "\->write ($filehandle, \f(CW$data\fP [, \f(CW$port\fP, \f(CW$addr\fP [, \f(CW$addr\fP ...]])"
.IX Subsection "->write ($filehandle, $data [, $port, $addr [, $addr ...]])"
Writes \f(CW$data\fR to \f(CW$filehandle\fR.  \f(CW$filehandle\fR must have been
previously registered as a \*(L">\*(R", \*(L"+\*(R", or \*(L"*\*(R" pipe.  If \*(L">\*(R" or
\&\*(L"+\*(R", not all of the data is guaranteed to be written upon
completion of this call; if the output pipe is full, the data
may be queued for future output by some subsequent
\&\f(CW$obj\fR\->getevents or \f(CW$obj\fR\->write.  If \*(L"*\*(R", the message will be
sent immediately to \f(CW$port\fR at \f(CW$addr\fR.  A failure will be
returned in this case if the write does not succeed
immediately.  Each \f(CW$addr\fR can be a dot-notation \s-1IP\s0 address or a
hostname, or the first and only \f(CW$addr\fR can be a listref
containing 4\-byte \s-1IP\s0 addresses.  Returns ($ok, \f(CW$msg\fR) where \f(CW$ok\fR
is true on success, false on failure.  On failure, \f(CW$msg\fR is an
error message.
.ie n .SS "\->expect ($receive_pipe, $to_receive, $timeout)"
.el .SS "\->expect ($receive_pipe, \f(CW$to_receive\fP, \f(CW$timeout\fP)"
.IX Subsection "->expect ($receive_pipe, $to_receive, $timeout)"
Blocks until  the entire   input on   registered \f(CW$receive_pipe\fR
matches regular expression  \f(CW$to_receive\fR, or no activity occurs
on the pipe for \f(CW$timeout\fR  seconds, or \f(CW$receive_pipe\fR closes.  A
timeout of \-1 is infinite.  The  regular expression is in Perl
format, with delimiters.
.PP
This is probably only meaningful on stream connections.
.PP
Returns an array of five elements:
.PP
.Vb 1
\&            (\-match\-, \-input\-, \-pipe_up\-, \-pipe_code\-, \-syntax\-)
\&
\&                \-match\-     ::= 1 if the whole input matched
\&                                $to_receive, 0 o.w.
\&                \-input\-     ::= The input received
\&                \-pipe_up\-   ::= 1 if $receive_pipe is still open, 0 o.w.
\&                \-pipe_code\- ::= The pipe termination code if \-pipe_up\- == 0
\&                \-syntax\-    ::= "" if no syntax error in the regular
\&                                expression $to_receive, a Perl error
\&                                message o.w.
.Ve
.SS "\->close_on_flush ($filehandle)"
.IX Subsection "->close_on_flush ($filehandle)"
Sets the registered writable filehandle to close and terminate
after all previously written data has been output.  Note that,
for socket connections, even outputing the data does not
guarantee that it will be delivered before the close (unless
\&\s-1SO_LINGER\s0 has been set).  Subsequent attempts to write to this
filehandle will fail.  Returns 1 on success, 0 if the
filehandle is not currently registered.  A filehandle termination
event will be sent on filehandle close.
.ie n .SS "\->set_read_buf_limit ($handle, $size)"
.el .SS "\->set_read_buf_limit ($handle, \f(CW$size\fP)"
.IX Subsection "->set_read_buf_limit ($handle, $size)"
Set the read & write buffer size limits & terminators.  These
change the handling of buffer full conditions to the following
cases:
.PP
.Vb 1
\&          Read buffer exceeds limit, no terminator, event(s) pending:
\&
\&            Flow control backpressure is exerted by not doing more
\&            reads on that handle until events are retrieved from that
\&            handle with getevents().
\&
\&          Read buffer exceeds limit, no terminator, no events pending:
\&
\&            Handle is closed and a termination event is posted.
\&
\&          Read buffer exceeds limit, terminator specified:
\&
\&            Handle is closed and a termination event is posted.
\&
\&          Write buffer exceeds limit, no terminator:
\&
\&            No reads will be done on any registered handle (thus
\&            exerting flow control backpressure on *all* registered
\&            read handles) until the write buffer is completely cleared
\&            for that handle.
\&
\&          Write buffer exceeds limit, terminator specified, no stop_msg:
\&
\&            Handle is closed and a termination event is returned.
\&
\&          Write buffer exceeds limit, terminator specified, stop_msg specified:
\&
\&            The write buffer is cleared and replaced by the contents
\&            of $stop_msg, and the handle is set to close_on_flush.
.Ve
.PP
When a handle is first registered its buffer limit size(s) are
set to 1MB and its terminator(s) are unspecified.
.ie n .SS "\->set_read_buf_limit_terminator ($handle, $do_terminate)"
.el .SS "\->set_read_buf_limit_terminator ($handle, \f(CW$do_terminate\fP)"
.IX Subsection "->set_read_buf_limit_terminator ($handle, $do_terminate)"
See set_read_buf_limit.
.ie n .SS "\->set_write_buf_limit ($handle, $size)"
.el .SS "\->set_write_buf_limit ($handle, \f(CW$size\fP)"
.IX Subsection "->set_write_buf_limit ($handle, $size)"
See set_read_buf_limit.
.ie n .SS "\->set_write_buf_limit_terminator ($handle, $do_terminate, [$stop_msg])"
.el .SS "\->set_write_buf_limit_terminator ($handle, \f(CW$do_terminate\fP, [$stop_msg])"
.IX Subsection "->set_write_buf_limit_terminator ($handle, $do_terminate, [$stop_msg])"
See set_read_buf_limit.
.SS "\->\fIreaders()\fP"
.IX Subsection "->readers()"
Returns a list of filehandles currently registered for
reading.
.SS "\->\fIwriters()\fP"
.IX Subsection "->writers()"
Returns a list of filehandles currently registered for
writing.
.SS "\->\fIwrite_blocked()\fP"
.IX Subsection "->write_blocked()"
Returns a list of filehandles (either strings or FileHandles)
currently blocked on output.
.SS "\->\fIwrite_blocked_size()\fP"
.IX Subsection "->write_blocked_size()"
Returns a hashref mapping filehandle names (always converted
to strings) currently blocked on output to the number of bytes
awaiting output.
.SS "c_socket(domain,type,protocol)"
.IX Subsection "c_socket(domain,type,protocol)"
Returns ($ok, \f(CW$msg\fR, \f(CW$fd\fR) where \f(CW$fd\fR is the file descriptor
obtained from the system call \fIsocket\fR\|(2).
\&\f(CW$ok\fR is true on success.  \f(CW$msg\fR is an error message on failure,
in which case \f(CW$fd\fR will be undef.
.SS "c_socketpair(domain,type,protocol)"
.IX Subsection "c_socketpair(domain,type,protocol)"
Returns ($ok, \f(CW$msg\fR, \f(CW$fd0\fR, \f(CW$fd1\fR) where \f(CW$fd0\fR and \f(CW$fd1\fR are the file descriptors
obtained from the system call \fIsocketpair\fR\|(2).
\&\f(CW$ok\fR is true on success.  \f(CW$msg\fR is an error message on failure,
in which case \f(CW$fd0\fR and \f(CW$fd1\fR will be undef.
.SS "c_getsockopt(fd,level,optname)"
.IX Subsection "c_getsockopt(fd,level,optname)"
Returns ($ok, \f(CW$msg\fR, \f(CW$value\fR) where \f(CW$value\fR is the result
obtained from the system call \fIgetsockopt\fR\|(2).
\&\f(CW$ok\fR is true on success.  \f(CW$msg\fR is an error message on failure,
in which case \f(CW$value\fR will be undef.
.SS "c_setsockopt(fd,level,optname)"
.IX Subsection "c_setsockopt(fd,level,optname)"
Returns ($ok, \f(CW$msg\fR) from the system call \fIsetsockopt\fR\|(2).
\&\f(CW$ok\fR is true on success.  \f(CW$msg\fR is an error message on failure.
.SS "c_bind(fd,addr)"
.IX Subsection "c_bind(fd,addr)"
Returns ($ok, \f(CW$msg\fR) from the system call \fIbind\fR\|(2).
\&\f(CW$ok\fR is true on success.  \f(CW$msg\fR is an error message on failure.
.SS "c_listen(fd,backlog)"
.IX Subsection "c_listen(fd,backlog)"
Returns ($ok, \f(CW$msg\fR) from the system call \fIlisten\fR\|(2).
\&\f(CW$ok\fR is true on success.  \f(CW$msg\fR is an error message on failure.
.SS "c_accept(fd)"
.IX Subsection "c_accept(fd)"
Returns ($ok, \f(CW$msg\fR, \f(CW$new_fd\fR, \f(CW$addr\fR) from the system call \fIaccept\fR\|(2).
\&\f(CW$ok\fR is true on success.  \f(CW$msg\fR is an error message on failure.
\&\f(CW$new_fd\fR is the new file descriptor accepted, and \f(CW$addr\fR is the
struct sockaddr encoding its address.
.SS "c_connect(fd,addr)"
.IX Subsection "c_connect(fd,addr)"
Returns ($ok, \f(CW$msg\fR) from the system call \fIconnect\fR\|(2).
\&\f(CW$ok\fR is true on success.  \f(CW$msg\fR is an error message on failure.
\&\f(CW$addr\fR is the struct sockaddr encoding the address to connect to.
.SH "AUTHOR"
.IX Header "AUTHOR"
Doug Campbell, \f(CW\*(C`<doug.campbell at pobox.com>\*(C'\fR
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Cam::Scom
.Ve
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2006,2007,2009 Doug Campbell
.PP
This file is part of Cam-Scom.
.PP
Cam-Scom is free software; you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.
.PP
Cam-Scom is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the
\&\s-1GNU\s0 General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with Cam-Scom; if not, see <http://www.gnu.org/licenses/>.
