.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Satc 3"
.TH Satc 3 "2012-03-22" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Satc \- Simple ASCII Telephony Control
.SH "VERSION"
.IX Header "VERSION"
Version 0.12
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1SATC\s0 is a telephony protocol used by phoneglue and voiceglue.
It defines messages that pass between a provider (server) of telephony
services and a user (client) of telephony services.
This package provides constants defining the \s-1SATC\s0 message types
(e.g. Satc::START, Satc::STOP, ...) and methods for
encoding and decoding \s-1SATC\s0 messages.
.PP
.Vb 1
\&    use Satc;
\&
\&    my ($ok, $msg, $bytes);
\&    my $proto = Satc\->new();
\&    my $satc_message = {Satc::MSGTYPE => Satc::START};
\&    ($ok, $msg, $bytes) = $proto\->encode ($satc_message);
\&    $ok || die ($msg);
\&    print ::FH ($bytes);
\&    $bytes = <::FH>
\&    ($ok, $msg, $satc_message) = $proto\->decode ($bytes);
\&    $ok || die ($msg);
\&    ($satc_message\->{Satc::STATUS} == 0) || die ($satc_message\->{Satc::MSG});
\&
\&    $hashed = Satc::hashify ($to_hash, $preserve_prefix_count, 
\&                             $suffix_blocks_count);
.Ve
.SS "Message Representation"
.IX Subsection "Message Representation"
A \s-1SATC\s0 message is represented by a simple hashref mapping field names
to their values.  The field types, field names, and the field name
constant definitions are as follows:
.PP
.Vb 10
\&    type     field        fieldname\-constant
\&    \-\-\-\-     \-\-\-\-\-        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Common to messages from clients and servers:
\&    int     msgtype       MSGTYPE      //  one of the msgtype constants:
\&      //  START, STARTED, STOP, STOPPED, REG, REGED, UNREG, UNREGED,
\&      //  ALLOWIN, ALLOWEDIN, STOPIN, STOPPEDIN, MAKECALL, MADECALL, INCOMING,
\&      //  ANSWER, ANSWERED, HANGUP, HUNGUP, PLAY, PLAYED, RECORD, RECORDED,
\&      //  CLEARDIG, DIGCLEARED, GETDIG, GOTDIG, PLAYDIG, PLAYEDDIG, STOPMEDIA,
\&      //  SUPPORTS, SUPPORTED, MAKECONF, MADECONF, JOINCONF, JOINEDCONF,
\&      //  EXITCONF, EXITEDCONF, BRIDGE, BRIDGED, UNBRIDGE, UNBRIDGED,
\&      //  TRANSFER, TRANSFERED, ASRSTART, ASRSTARTED, ASRSTOP, ASRSTOPPED,
\&      //  LOADGRAMMAR, LOADEDGRAMMAR, UNLOADGRAMMAR, UNLOADEDGRAMMAR,
\&      //  STARTGRAMMAR, STARTEDGRAMMAR, STOPGRAMMAR, STOPPEDGRAMMAR,
\&      //  RECOGNIZE, RECOGNIZED, RETURNVAR, RETURNEDVAR, RELEASE, RELEASED
\&    int      callid       CALLID       //  for almost all
\&    String   digits       DIGITS       //  for playdig, gotdig, recorded
\&    int      makecall_id  MAKECALL_ID  //  for makecall, madecall
\&    int      confid       CONFID       //  for makeconf and joinconf
\&    String   grammarname  GRAMMARNAME  //  for loadgrammar, loadedgrammar,
\&                                               unloadgrammar, unloadedgrammar,
\&                                               startgrammar, startedgrammar,
\&                                               stopgrammar, stoppedgrammar,
\&  For messages from clients only:
\&    String   toself       TOSELF       //  for start
\&    String   url          URL          //  for reg, unreg, makecall (to),
\&                                               asrstart
\&    String   from         FROM         //  for makecall (from), transfer
\&    String   file         FILE         //  for record, loadgrammar
\&    String[] files        FILES        //  for play
\&    String   stopkeys     STOPKEYS     //  for play, record, getdig
\&    int      load         LOAD         //  for reg load
\&    int      timeout      TIMEOUT      //  for makecall getdig record transfer
\&    int      max_time     MAX_TIME     //  for record
\&    int      max_dig      MAX_DIG      //  for getdig
\&    int      start_tone   START_TONE   //  for record
\&    int      other_callid OTHER_CALLID //  for bridge
\&    String   mix          MIX          //  for record
\&    int      flag         FLAG         //  for recognize
\&    String   var          VAR          //  for returnvar
\&    String   value        VALUE        //  for returnvar
\&  For messages from servers only:
\&    int      status       STATUS
\&    String   msg          MSG
\&    String   ani          ANI          // for incoming
\&    String   dnis         DNIS         // for incoming
\&    String   arg          ARG          // for incoming
\&    int      reason       REASON       // for played, recorded, gotdig,
\&                                          recognized
\&    int      duration     DURATION     // for recorded
.Ve
.PP
Note that if the above pre-defined constants are imported and
then used as field names within a \s-1SATC\s0 message without a leading
package specifier, you must put () after the field
name to prevent them from being interpreted as string literals:
.PP
.Vb 5
\&               use Satc qw(STOPKEYS);
\&  right:       $satc_message\->{Satc::FILE()} = "foo.wav";
\&  right:       $satc_message\->{Satc::FILE} = "foo.wav";
\&  right:       $satc_message\->{STOPKEYS()} = "#";
\&  wrong:       $satc_message\->{STOPKEYS} = "#";
.Ve
.PP
Additional constants are defined for the \*(L"reason\*(R" field values:
.PP
.Vb 10
\&    PLAYEDFILE_REASON_UNDETERMINED
\&    PLAYEDFILE_REASON_END_OF_DATA
\&    PLAYEDFILE_REASON_DTMF_PRESSED
\&    PLAYEDFILE_REASON_STOP_REQUESTED
\&    RECORDED_REASON_UNDETERMINED
\&    RECORDED_REASON_SILENCE
\&    RECORDED_REASON_DTMF_PRESSED
\&    RECORDED_REASON_STOP_REQUESTED
\&    RECORDED_REASON_MAX_TIME
\&    RECORDED_REASON_NO_AUDIO_TIMEOUT
\&    RECORDED_REASON_HANGUP
\&    GOTDIGIT_REASON_UNDETERMINED
\&    GOTDIGIT_REASON_TERM_PRESSED
\&    GOTDIGIT_REASON_MAX_DIGITS
\&    GOTDIGIT_REASON_TIMEOUT
\&    GOTDIGIT_REASON_STOP_REQUESTED
\&    RECOGNIZED_REASON_UNDETERMINED
\&    RECOGNIZED_REASON_NOMATCH
\&    RECOGNIZED_REASON_DTMF_PRESSED
\&    RECOGNIZED_REASON_STOP_REQUESTED
\&    RECOGNIZED_REASON_NO_AUDIO_TIMEOUT
\&    RECOGNIZED_REASON_HANGUP
.Ve
.SS "The \s-1SATC\s0 wire protocol"
.IX Subsection "The SATC wire protocol"
.Vb 10
\&  Message Format
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  SATC servers listen for TCP connections on port 44647.
\&  SATC clients connect to SATC servers using TCP.
\&  Every message is terminated by a \en (ASCII 10).
\&  Every message contains one or more fields.
\&  Fields begin at non\-whitespace characters.  Fields end at
\&  whitespace characters unless the whitespace appears between
\&  non\-escaped matching quote characters " (ASCII 34) or \*(Aq (ASCII 39)
\&  in which case the field characters include the whitespace.
\&  An unescaped quote character of one type within another\*(Aqs is not
\&  treated specially, but is treated as if it were escaped.
\&  Escaping rules are:
\&    \e\e = "\e" (ASCII 92)
\&    \en = "\en" (ASCII 10)
\&    \e" = """ (ASCII 34)
\&    \e\*(Aq = "\*(Aq" (ASCII 39)
\&    \exDD = ASCII character corresponding to hex digits DD
\&  A backslash (ASCII 92) followed by any other character
\&  sequence is an error.  Escaping rules apply to any character sequence
\&  or byte field, even those not enclosed by quote characters.
\&
\&  The first field in a SATC message is always the message type.
\&  This type defines the meanings of subsequent data elements (if any).
\&  Recipients of SATC messages are required to ignore any message types they
\&  do not process, and to ignore any additional fields in messages that
\&  they do not use.
\&
\&  Data types are implicit in SATC messages, and apply only
\&  to interpretation, not to representation.
\&  String types are interpreted as sequences of bytes.
\&  Integer types are interpreted as ASCII decimal numbers.
\&
\&  Client \-> Server Message Types
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&      NOTE:  All messages from client to server will
\&             result in a response message (described below).
\&             Response messages will be sent upon completion of
\&             the request.
\&
\& * = not yet implemented
\&
\&    Type            Additional Data                       Description
\&    \-\-\-\-            \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-                       \-\-\-\-\-\-\-\-\-\-\-
\&    start           toself                                Init connection
\&    stop            <none>                                End connection
\&    reg             string url, int load                  Register DID
\&    unreg           string url                            Unregister DID
\&    allowin         <none>                                Allow incoming
\&    stopin          <none>                                Stop incoming
\&    answer          int callid                            Answer a call
\&    makecall        string url, string from, int timeout, Make a new call
\&                          int makecall_id
\&    hangup          int callid                            Hangup a call
\&    play            int callid, string files,             Play a file
\&                            string stopkeys
\&    record          int callid, string file,              Record to file
\&                            string start_tone,
\&                            int timeout, int max_time,
\&                            string stopkeys, string mix
\&    cleardig        int callid                            Clear digit buf
\&    getdig          int callid, int timeout,              Get digits
\&                            string stopkeys, int max_dig      collected
\&    playdig         int callid, string digits             Play digits
\&    stopmedia       int callid                            stop playing
\&    supports        <none>                                show supported msgs
\& *  makeconf        int callid, int confid                Make a conference
\& *  joinconf        int callid, int confid,               Join a conference
\& *  exitconf        int callid                            Exit a conference
\&    bridge          int callid, int req_callid            Bridge calls
\&    unbridge        int callid                            Unbridge calls
\&    transfer        int callid, string url, int flag,     Transfer
\&                        string from, int timeout
\&    asrstart        int callid, string url                Init ASR for call
\&    asrstop         int callid                            Stop ASR on call
\&    loadgrammar     int callid, string grammarname,       Load ASR grammar
\&                             string file
\&    unloadgrammar   int callid, string grammarname        Unload ASR grammar
\&    startgrammar    int callid, string grammarname,       Activate ASR grammar
\&    stopgrammar     int callid, string grammarname        DeActivate ASR grammar
\&    recognize       int callid, string files,             Do speech recognition
\&                             int timeout, int flag
\&    returnvar       int callid, string var, string value  Return values to ast
\&    release         int callid                            exit call, no hangup
\&
\&  Server \-> Client Message Types
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&      NOTE:  All messages except incoming, hungup, exitedconf, and unbridged
\&             are responses to client request messages.
\&               The incoming, hungup, exitedconf, and unbridged messages
\&             are asynchronous event messages or responses to requests.
\&
\&      NOTE:  All (int status, string msg) pairs indicate a success/failure
\&             result code in status, along with an (empty if success)
\&             error message in msg.  status == 0 is success, != 0 is failure.
\&
\& * = not yet implemented
\&
\&    Type        Additional Data
\&    \-\-\-\-        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    started     int status, string msg
\&    stopped     int status, string msg
\&    reged       int status, string msg
\&    unreged     int status, string msg
\&    allowedin   int status, string msg
\&    stoppedin   int status, string msg
\&    incoming    int callid, string ani, string dnis, string arg
\&    hungup      int callid
\&    answered    int callid, int status, string msg
\&    madecall    int callid, int makecall_id, int status, string msg
\&    played      int callid, int status, string msg, int reason
\&    recorded    int callid, int status, string msg, int reason, int duration, string digits
\&    digcleared  int callid, int status, string msg
\&    gotdig      int callid, int status, string msg, int reason, string digits
\&    playeddig   int callid,int status, string msg
\& *  supported   int msg1, string msg1_format, int msg2, ...
\& *  madeconf    int callid, int status, string msg, int confid
\& *  joinedconf  int callid, int status, string msg
\& *  exitedconf  int callid
\&    bridged     int callid, int status, string msg
\&    unbridged   int callid
\&    transfered  int callid, int status, string msg
\&    asrstarted  int callid, int status, string msg
\&    asrstopped  int callid, int status, string msg
\&    loadedgrammar    int callid, int status, string msg, string grammarname
\&    unloadedgrammar  int callid, int status, string msg, string grammarname
\&    startedgrammar   int callid, int status, string msg, string grammarname
\&    stoppedgrammar   int callid, int status, string msg, string grammarname
\&    recognized       int callid, int status, string msg, int reason
\&    returnedvar      int callid
\&    released         int callid
\&
\&
\&  Message Synchronization
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  All client request messages will ultimately be reponded to with their
\&  corresponding response messages with the following exception:
\&
\&  * Hungup Exception:   After a client has sent any of the request
\&                          messages answer, play,
\&                          record, cleardig, getdig, playdig,
\&                          makeconf, joinconf, exitconf, bridge, or
\&                          unbridge, it could receive a
\&                          hungup message from the server for
\&                          that callid instead of the corresponding
\&                          response.  The hungup message is the
\&                          last message that will be sent from the server
\&                          regarding that callid.  It must be accepted by a
\&                          client as a terminating response for the above
\&                          listed requests.
\&
\&  Messages are further categorized below into four classes:
\&
\&    config:       start stop reg unreg allowin stopin supports
\&    callcontrol:  answer hangup makecall returnvar release
\&    media:        play record cleardig getdig playdig stopmedia
\&    conference:   makeconf joinconf exitconf bridge unbridge
\&
\&  It is illegal for a client to have more than one outstanding request
\&  in a category for a callid (or overall for the config class).
\&  The one exception is stopmedia which may be
\&  issued at any time.
\&
\&  It is illegal for a client to send any media or
\&  conference class messages for a call until a successful
\&  answered or madecall message is received for that call.
\&  An exception is that play can occur on incoming calls
\&  before an answer is processed.
\&
\&
\&  Details of Messages
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  msg:        start
\&  direction:  Client \-> Server
\&  class:      config
\&  parameters: toself
\&  function:   This must be the first message sent by a client to a server.
\&              The client must not send any more messages until a started
\&              message is received in response.
\&              The toself parameter specifies how outbound calls and
\&              redirects are to be addressed back into the telephony provider.
\&              It can be the empty string if no outbound calls or redirects
\&              (used by stopmedia) are used, otherwise for asterisk specify
\&              "context:extension:priority".
\&
\&  msg:        started
\&  direction:  Server \-> Client
\&  class:      config
\&  parameters: int status         \-\- 0 on success, non\-0 on failure.
\&              string msg         \-\- If failure, an error message
\&  function:   Response to a start message.
\&
\&  msg:        stop
\&  direction:  Client \-> Server
\&  class:      config
\&  parameters: <none>
\&  function:   This must be the last message sent by a client to a server.
\&
\&  msg:        stopped
\&  direction:  Server \-> Client
\&  class:      config
\&  parameters: int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&  function:   Response to an stop message.
\&
\&  msg:        reg
\&  direction:  Client \-> Server
\&  class:      config
\&  parameters: string url         \-\- The inbound phone number(s) or URI(s)
\&                                    this client is willing to accept
\&                                    incoming calls for.  String can contain
\&                                    wildcard character "*".  If the string
\&                                    contains only digits, "(", ")", "\-", and
\&                                    wildcards, it is considered a phone
\&                                    number versus a URI.
\&              int load           \-\- A load relative to other clients.
\&                                    For example, if this client specifies a
\&                                    load of 10, and two other clients have
\&                                    each specified a load of 20 for the same
\&                                    DID, then this client will get 20% of the
\&                                    incoming calls for this DID, and the
\&                                    other clients will get 40% each.
\&  function:   Establishes that this client is willing to accept incoming
\&              calls destined for the specified DID(s).  None will actually
\&              be delivered unless and until the allowin function succeeds.
\&              Will always be responded to with a reged message.
\&
\&  msg:        reged
\&  direction:  Server \-> Client
\&  class:      config
\&  parameters: int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&  function:   Response to a reg message.
\&
\&  msg:        unreg
\&  direction:  Client \-> Server
\&  class:      config
\&  parameters: string url         \-\- The inbound phone number(s) or URI(s)
\&                                    this client is no longer willing to
\&                                    accept incoming calls for.  String has
\&                                    the same format as in the reg message.
\&                                    It must be an exact match to a previous
\&                                    reg message url string parameter.
\&  function:   Establishes that this client is no longer willing to accept
\&              incoming calls destined for the specified DID(s).  Calls
\&              will stop being delivered once the unreged success
\&              message is received.
\&
\&  msg:        unreged
\&  direction:  Server \-> Client
\&  class:      config
\&  parameters: int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&  function:   Response to an unreg message.
\&
\&  msg:        allowin
\&  direction:  Client \-> Server
\&  class:      config
\&  parameters: <none>
\&  function:   Requests that the server begin sending incoming calls to
\&              this client for all registered DIDs.  Incoming calls will
\&              begin to appear after the allowedin success response
\&              is received.
\&
\&  msg:        allowedin
\&  direction:  Server \-> Client
\&  class:      config
\&  parameters: int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&  function:   Response to an allowin message.
\&
\&  msg:        stopin
\&  direction:  Client \-> Server
\&  class:      config
\&  parameters: <none>
\&  function:   Requests that the server stop sending incoming calls to
\&              this client for all registered DIDs.  Incoming calls will
\&              stop appearing after the stoppedin success response
\&              is received.
\&
\&  msg:        stoppedin
\&  direction:  Server \-> Client
\&  class:      config
\&  parameters: int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&  function:   Response to a stopin message.
\&
\&  msg:        incoming
\&  direction:  Server \-> Client
\&  class:      <event>
\&  parameters: int callid         \-\- A unique (across all servers) identifier
\&                                    for this call
\&              string ani         \-\- A string describing the calling entity,
\&                                    for normal phone numbers a digit string.
\&              string dnis        \-\- A string describing the called entity,
\&                                    for normal phone numbers a digit string.
\&              string arg         \-\- The agi_network_script value passed from
\&                                    asterisk when the AGI call was made.
\&  function:   Notifies a client that it has been chosen to handle the
\&              callflow for this incoming call.  The call is in an unanswered
\&              state.
\&
\&  msg:        answer
\&  direction:  Client \-> Server
\&  class:      callcontrol
\&  parameters: int callid         \-\- The callid of the call to answer.
\&  function:   Requests that the server answer the call corresponding
\&              to the callid, which must match a callid provided in a
\&              previous incoming message.
\&
\&  msg:        answered
\&  direction:  Server \-> Client
\&  class:      callcontrol
\&  parameters: int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&  function:   Response to an answer message.
\&
\&  msg:        makecall
\&  direction:  Client \-> Server
\&  class:      callcontrol
\&  parameters: string url         \-\- The number or URI to call.  Must be in
\&                                    Asterisk form, e.g. "sip/<URL>"
\&              string from          \-\- The number or URI calling from.
\&              int timeout        \-\- The number of ms to wait for answer.
\&              int makecall_id    \-\- A unique number generated by the client
\&                                      to identify this makecall request.
\&  function:   Requests that the server start a new call to the specified
\&              destination.
\&
\&  msg:        madecall
\&  direction:  Server \-> Client
\&  class:      callcontrol
\&  parameters: int callid         \-\- A unique (across all servers) identifier
\&                                    for this call
\&                int makecall_id    \-\- Matches the makecall_id passed in the
\&                                      makecall message from the client
\&              int status         \-\- The result of the makecall, one of:
\&                                      0 = connection succeeded
\&                                      1 = system failure
\&                                      2 = line is busy
\&                                      3 = no answer (timeout)
\&                                      4 = call rejected
\&              int msg            \-\- If system failure, an error message
\&  function:   Response to a makecall message.  If status == 0 (success), this
\&              indicated that callid identifies a new call that is connected
\&              to the destination requested in the makecall message.  The
\&              client is now responsible for callflow for this call.  If
\&              status == 1 (system failure), msg will contain an error msg.
\&              If status != 0, callid will be meaningless.
\&
\&  msg:        hangup
\&  direction:  Client \-> Server
\&  class:      callcontrol
\&  parameters: int callid         \-\- The callid of the call to hangup.
\&  function:   Requests that the server hangup the call with this callid.
\&              If the call is not currently connected, no response is given.
\&              Otherwise, the server must reply with a hungup message.
\&
\&  msg:        hungup
\&  direction:  Server \-> Client
\&  class:      callcontrol
\&  parameters: int callid         \-\- The callid of the hungup call.
\&  function:   Notifies the client that the call with this callid has
\&              been disconnected.  No further activity can occur for
\&              this callid unless and until it is reused for a new call
\&              (via either incoming or makecall).
\&
\&  msg:        release
\&  direction:  Client \-> Server
\&  class:      callcontrol
\&  parameters: int callid         \-\- The callid of the call to release
\&  function:   Requests that the server release the call with this callid.
\&              If the call is not currently connected, no response is given.
\&              Otherwise, the server must reply with a released message.
\&              This provides a way to return control to an enclosing
\&              execution environment without hanging up the call.
\&
\&  msg:        released
\&  direction:  Server \-> Client
\&  class:      callcontrol
\&  parameters: int callid         \-\- The callid of the released call.
\&  function:   Notifies the client that the call with this callid has
\&              been released.  No further activity can occur for
\&              this callid unless and until it is reused for a new call
\&              (via either incoming or makecall).
\&
\&  msg:        play
\&  direction:  Client \-> Server
\&  class:      media
\&  parameters: int callid         \-\- The call on which to play the media.
\&              string files       \-\- The list of files to play.  If more than
\&                                    one file is specified, the names must
\&                                    be separated by the "|" character.
\&                                    Each file may have appended the string
\&                                    "^start=XXX" where XXX is an offset in
\&                                    ms into the file where play should begin.
\&              string stopkeys    \-\- An ASCII string of the keys that will
\&                                    stop a play, record, or getdig.
\&                                    Valid keys are "#", "*", "0" \- "9",
\&                                    and if VAMD is available, "m", "h", and
\&                                    "t".  Keys can be in any order.
\&  function:   Requests that the specified media files be played on the
\&              specified call.  Play will be terminated on the following
\&              conditions:
\&                  1: A key has been pressed matching the stopkeys and has
\&                     not been cleared from the key buffer via cleardig
\&                     or getdig.
\&                  2: The files have finished playing.
\&                  3: A stopmedia message is received.
\&                  4: The call is disconnected.
\&              If condition 1 is matched before any media starts playing,
\&              a played message will be sent immediately.
\&              Otherwise, if conditions 1\-3 subsequently terminate
\&              the play, a played will then be sent.  If condition 4
\&              terminates the play, no played will be sent, only a
\&              hungup will be sent.
\&
\&  msg:        played
\&  direction:  Server \-> Client
\&  class:      media
\&  parameters: int callid         \-\- The call on which the media files have
\&                                    finished playing.
\&              int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&              int reason         \-\- One of the following reason codes:
\&                                         0 = undetermined
\&                                         1 = end of data
\&                                         2 = terminated by DTMF
\&                                         3 = terminated by request (stopmedia)
\&  function:   Sent to indicate that a play request has finished
\&              playing.
\&
\&  msg:        record
\&  direction:  Client \-> Server
\&  class:      media
\&  parameters: int callid         \-\- The call on which to record.
\&              string file        \-\- The file into which to record.
\&              string start_tone  \-\- One of "tone" or "notone" for whether
\&                                    to play a start tone for the record.
\&              int timeout        \-\- Max ms of silence that stop recording.
\&              int max_time       \-\- Max ms of total recording.
\&              string stopkeys    \-\- An ASCII string of the keys that will
\&                                    stop a play, record, or getdig.
\&                                    Valid keys are "#", "*", "0" \- "9",
\&                                    and if VAMD is available, "m", "h", and
\&                                    "t".  Keys can be in any order.
\&              string mix         \-\- One of "inbound" or "mix".  "mix" records
\&                                    a mix of both inbound and outbound audio.
\&                                    "inbound" records only inbound.
\&  function:   Requests that the incoming call audio be recorded into the
\&              specified media file.  Record will be terminated by any of:
\&                  1: A key has been pressed matching the stopkeys and has
\&                     not been cleared from the key buffer via cleardig
\&                     or getdig
\&                  2: Record stops based on timeout or max_time.
\&                  3: The call is disconnected.
\&              If condition 1 is matched before any media starts playing,
\&              a recorded message will be sent immediately.  Otherwise,
\&              when conditions 1\-2 subsequently terminate the record,
\&              a recorded will then be sent.  If condition 3 terminates
\&              the recording, a recorded will first be sent, then a hungup.
\&
\&  msg:        recorded
\&  direction:  Server \-> Client
\&  class:      media
\&  parameters: int callid         \-\- The call on which the media file has
\&                                    finished recording.
\&              int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&              int reason         \-\- One of the following reason codes:
\&                                         0 = undetermined
\&                                         1 = terminated by silence
\&                                         2 = terminated by DTMF
\&                                         3 = terminated by request
\&                                         4 = max_time of recording detected
\&                                         5 = no audio start (noinput)
\&                                         6 = terminated by hangup
\&              int duration       \-\- How long the recording is in ms
\&              string digits      \-\- The digit (if any) pressed to terminate
\&  function:   Sent to indicate that a record request has finished
\&              recording.
\&
\&  msg:        cleardig
\&  direction:  Client \-> Server
\&  class:      media
\&  parameters: int callid         \-\- The callid of call to clear digits on.
\&  function:   Requests that the server forget any sensed digits that
\&              have been pressed by the user up to this point.  Any such
\&              digits cleared will not terminate subsequent plays or records,
\&              nor be retrievable with getdig.  The server will respond with
\&              a digcleared message.
\&
\&  msg:        digcleared
\&  direction:  Server \-> Client
\&  class:      media
\&  parameters: int callid         \-\- The callid of the call.
\&              int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&  function:   Response to a cleardig request.
\&
\&  msg:        getdig
\&  direction:  Client \-> Server
\&  class:      media
\&  parameters: int callid         \-\- The call on which to get digits.
\&              int timeout        \-\- Max ms to wait for digits, can be
\&                                    0 to indicate no wait.
\&              string stopkeys    \-\- An ASCII string of the keys that will
\&                                    stop a play, record, or getdig.
\&                                    Valid keys are "#", "*", "0" \- "9",
\&                                    and if VAMD is available, "m", "h", and
\&                                    "t".  Keys can be in any order.
\&              int max_dig        \-\- The maximum number of digits to return.
\&  function:   Requests that the server return the digits that have been
\&              pressed on the call since the last cleardig minus those
\&              that have already been retrieved with getdig.
\&              Digits will be sent back to the client (thus terminating this
\&              getdig request) on the following conditions:
\&                  1: A key has been pressed matching the stopkeys and has
\&                     not been cleared from the key buffer via cleardig
\&                     or getdig
\&                  2: max_dig digits have been obtained with no stopkeys found
\&                  3: Timeout ms have expired without stopkeys pressed
\&                     or max_dig being attained.
\&                  4: User requested termination.
\&                  5: The call is disconnected.
\&              If conditions 1\-3 are matched immediately by the existing
\&              digit buffer contents and/or a timeout of 0, a
\&              gotdig message will be sent immediately.  Otherwise,
\&              when conditions 1\-4 subsequently terminate the collection,
\&              a gotdig will then be sent.  If condition 5 terminates
\&              the digit collection, no gotdig will be sent, only a hungup.
\&
\&  msg:        gotdig
\&  direction:  Server \-> Client
\&  class:      media
\&  parameters: int callid         \-\- The call on which the digit collection
\&                                    has finished.
\&              int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&              int reason         \-\- One of the following reason codes:
\&                                     0 = undetermined
\&                                     1 = terminated by stopdigits match.
\&                                     2 = terminated by max_digits received.
\&                                     3 = terminated by timeout ms done.
\&                                     4 = terminated by request.
\&              string digits      \-\- The digits retrieved, in ASCII format.
\&  function:   Sent to indicate that a getdig request has finished.
\&
\&  msg:        playdig
\&  direction:  Client \-> Server
\&  class:      media
\&  parameters: int callid         \-\- The call on which to play the digits.
\&              string digits      \-\- The ASCII\-formatted digits to play.
\&  function:   Requests that the specified digits be played on the
\&              specified call.  Play will be terminated on the following
\&              conditions:
\&                  1: The digits have finished playing.
\&                  2: A termination request is received.
\&                  3: The call is disconnected.
\&              When conditions 1\-2 subsequently terminate
\&              the play, a playeddig will then be sent.  If condition 3
\&              terminates the play, no playeddig will be sent, only a hungup.
\&
\&  msg:        playeddig
\&  direction:  Server \-> Client
\&  class:      media
\&  parameters: int callid         \-\- The call on which the digits have
\&                                    finished playing.
\&              int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&  function:   Sent to indicate that a playdig request has finished playing.
\&
\&  msg:        stopmedia
\&  direction:  Client \-> Server
\&  class:      media
\&  parameters: int callid         \-\- The callid of the call to stop play.
\&  function:   Requests that the server stop the current media activity.
\&              The server will terminate the media activity, and send
\&              a response appropriate for the media activity that was
\&              ongoing.  If no media activity is ongoing, has no effect.
\&
\&  msg:        supports
\&  direction:  Client \-> Server
\&  class:      config
\&  parameters: <none>
\&  function:   Requests that the server send a list of all supported
\&                messages.
\&
\&  msg:        supported
\&  direction:  Server \-> Client
\&  class:      config
\&  parameters: string msg1
\&                string msg2
\&                 . . .
\&                string msgN
\&  function:   Sent in response to a supports message, enumerates all messages
\&              from the client to the server supported by this server.
\&
\&  msg:        makeconf
\&  direction:  Client \-> Server
\&  class:      conference
\&  parameters: int callid         \-\- The callid of the call requesting
\&                                    the creation of the conference.
\&              int confid         \-\- The requested id of the conference.
\&  function:   Requests that a new conference be created with id confid.
\&              The server must respond with a madeconf message.
\&
\&  msg:        madeconf
\&  direction:  Server \-> Client
\&  class:      conference
\&  parameters: int callid         \-\- The call that previously called makeconf.
\&              int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&              int confid         \-\- The conference identifier
\&  function:   Sent in response to a makeconf message.
\&
\&  msg:        joinconf
\&  direction:  Client \-> Server
\&  class:      conference
\&  parameters: int callid       \-\- callid of the call joining the conference.
\&              string confid    \-\- The conference identifier
\&  function:   Requests that the server join call callid to conference
\&              id confid.  The server must respond with a joinedconf message.
\&
\&  msg:        joinedconf
\&  direction:  Server \-> Client
\&  class:      conference
\&  parameters: int callid         \-\- The call that previously called joinconf.
\&              int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&  function:   Sent in response to a joinconf message to establish
\&              the success or failure of joining the conference.
\&
\&  msg:        exitconf
\&  direction:  Client \-> Server
\&  class:      conference
\&  parameters: int callid       \-\- callid of the call exiting the conference.
\&  function:   Requests that the server stop the specified call from
\&              participating in its current conference.  It can be used
\&              to terminate either the host or the joiner of a conference.
\&              If the call is not currently in a conference, no response
\&              is given.
\&              Otherwise, the server must respond with a exitedconf
\&
\&  msg:        exitedconf
\&  direction:  Server \-> Client
\&  class:      conference
\&  parameters: int callid       \-\- callid of the call whose conference stopped
\&  function:   Sent when a call stops participating in a conference.
\&              Sent in response to an exitconf message, or asynchronously.
\&
\&  msg:  bridge
\&  direction:  Client \-> Server
\&  class:        conference
\&  parameters: int callid       \-\- callid of the call that wants to bridge
\&                int req_callid   \-\- callid of the call to bridge to
\&  function:   Requests that callid bridge to req_callid.  Both callid
\&              and req_callid must make this call specifying the other
\&              in order for the bridge to succeed and audio to pass.
\&              If the other side does not executes a corresponding bridge,
\&              this channel will be stuck with no audio until an unbridge
\&              is performed.
\&
\&  msg:        bridged
\&  direction:  Server \-> Client
\&  class:      conference
\&  parameters: int callid       \-\- callid of call that requested the bridge
\&                int status
\&                string msg
\&  function:   Response to a bridge message.
\&
\&  msg:  unbridge
\&  direction:  Client \-> Server
\&  class:        conference
\&  parameters: int callid          \-\- callid of the call that wants to unbridge
\&  function:   Requests that callid stop bridging.  Both calls in the bridge
\&              will be unbridged when either side executes an unbridge.
\&              Both will get an unbridged message.
\&
\&  msg:        unbridged
\&  direction:  Server \-> Client
\&  class:      conference
\&  parameters: int callid        \-\- callid of call that is now unbridged
\&            int status
\&            string msg
\&  function:   Response to an unbridge message, or async notification
\&
\&  msg:  transfer
\&  direction:  Client \-> Server
\&  class:        conference
\&  parameters: int callid       \-\- callid of the call that wants to transfer
\&              string url       \-\- The number or URI to call.  Must be in
\&                                  Asterisk form, e.g. "sip/<URL>"
\&              int flag         \-\- 0 = blind transfer (method=dial),
\&                                  1 = blind transfer (method=transfer)
\&                                  2 = bridged transfer (method=dial)
\&              string from      \-\- callerid (ANI) to call from ("" = default)
\&              int timeout      \-\- max ms to wait for connect (0 = forever)
\&  function:   Performs a transfer.  (For hosted transfers,
\&              perform an outbound call followed by a bridge).
\&              The transfered response message will not be
\&              sent until the outbound transfer call finishes.
\&              If the caller has not hungup, further operations
\&              on the call are then permitted.
\&
\&  msg:        transfered
\&  direction:  Server \-> Client
\&  class:      conference
\&  parameters: int callid       \-\- callid of call that requested the bridge
\&                int status
\&                string msg
\&  function:   Response to a bridge message.
\&              The call has finished the outbound leg,
\&              and is ready for further operation.
\&
\&  msg:        asrstart
\&  direction:  Client \-> Server
\&  class:      media
\&  parameters: int callid       \-\- call id of call to start ASR engine on
\&              string url       \-\- identifier of particular ASR engine
\&  function:   Initializes ASR engine on call.  No ASR message may be
\&              sent on this call  until a successful asrstarted message
\&              is received in response.
\&
\&  msg:        asrstarted
\&  direction:  Server \-> Client
\&  class:      media
\&  parameters: int callid         \-\- callid of call whose ASR engine started
\&              int status         \-\- 0 on success, non\-0 on failure.
\&              string msg         \-\- If failure, an error message
\&  function:   Response to an asrstart message.
\&
\&  msg:        asrstop
\&  direction:  Client \-> Server
\&  class:      media
\&  parameters: int callid       \-\- call id of call to stop ASR engine on
\&  function:   Stops the ASR capability.
\&
\&  msg:        asrstopped
\&  direction:  Server \-> Client
\&  class:      media
\&  parameters: int callid         \-\- callid of call whose ASR engine stopped
\&              int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&  function:   Response to an asrstop message.
\&
\&  msg:        loadgrammar
\&  direction:  Client \-> Server
\&  class:      media
\&  parameters: int callid         \-\- call id of call to load grammar for
\&              string grammarname \-\- identifier of particular grammar
\&              string file        \-\- file containing grammar
\&  function:   Loada an SRGS speech grammar for a call for later use
\&              by activategrammar.
\&
\&  msg:        loadedgrammar
\&  direction:  Server \-> Client
\&  class:      media
\&  parameters: int callid         \-\- call id of loaded grammar
\&              string grammarname \-\- identifier of particular grammar
\&              int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&  function:   Response to a loadgrammar message.
\&
\&  msg:        unloadgrammar
\&  direction:  Client \-> Server
\&  class:      media
\&  parameters: int callid         \-\- call id of call to unload grammar for
\&              string grammarname \-\- identifier of particular grammar
\&  function:   Unloada an SRGS speech grammar for a call
\&
\&  msg:        unloadedgrammar
\&  direction:  Server \-> Client
\&  class:      media
\&  parameters: int callid         \-\- call id of unloaded grammar
\&              string grammarname \-\- identifier of particular grammar
\&              int status         \-\- 0 on success, != 0 for failure
\&              string msg         \-\- If failure, an error message
\&  function:   Response to an unloadgrammar message.
.Ve
.SS "_encode_convert_escape ($value)"
.IX Subsection "_encode_convert_escape ($value)"
\&\s-1NOTE:\s0  This is an normally an internal routine, but may
be useful externally for quoting purposes.
.PP
Returns ($ok, \f(CW$msg\fR, \f(CW$bytes\fR) where \f(CW$ok\fR == 1 and \f(CW$bytes\fR is the
byte string of encoded \s-1SATC\s0 field \f(CW$value\fR on success,
\&\f(CW$ok\fR == 0 and \f(CW$msg\fR is a human-readable error message on failure.
This encoding will always surround \f(CW$value\fR with double quotes.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Reeturns a new \s-1SATC\s0 protocol object.
\&\s-1SATC\s0 protocol objects have no state
(at least, they could have none),
so their only reason for existing as
objects instead of functions is to
not pollute the namespace.
.SH "METHODS"
.IX Header "METHODS"
.SS "\->\fIprotocol_number()\fP"
.IX Subsection "->protocol_number()"
Returns the unique (to phoneglue) protocol number
of the \s-1SATC\s0 protocol, the number 1.
.SS "\->\fIprotocol_name()\fP"
.IX Subsection "->protocol_name()"
Returns the unique (to phoneglue) protocol name
of the \s-1SATC\s0 protocol, \*(L"\s-1SATC\s0\*(R".
.SS "\->\fImagic_byte()\fP"
.IX Subsection "->magic_byte()"
Returns the unique (to phoneglue) first byte of
the first message received from the \s-1SATC\s0 protocol.
.SS "\->describe_msgtype ($msgtype)"
.IX Subsection "->describe_msgtype ($msgtype)"
Returns a human-readable description of \s-1SATC\s0 message type \f(CW$msgtype\fR
.SS "\->describe_played_reason ($reason)"
.IX Subsection "->describe_played_reason ($reason)"
Returns a human-readable description of \s-1SATC\s0 played reason code
.SS "\->describe_recorded_reason ($reason)"
.IX Subsection "->describe_recorded_reason ($reason)"
Returns a human-readable description of \s-1SATC\s0 recorded reason code
.SS "\->describe_gotdigit_reason ($reason)"
.IX Subsection "->describe_gotdigit_reason ($reason)"
Returns a human-readable description of \s-1SATC\s0 gotdigit reason code
.SS "\->describe_recognized_reason ($reason)"
.IX Subsection "->describe_recognized_reason ($reason)"
Returns a human-readable description of \s-1SATC\s0 recognized reason code
.SS "\->describe_msg ($msg)"
.IX Subsection "->describe_msg ($msg)"
Returns a human-readable description of \s-1SATC\s0 message \f(CW$msg\fR
.SS "\->extract_message (\e$bytes)"
.IX Subsection "->extract_message ($bytes)"
Attempts to extract the next message in \f(CW$bytes\fR, returning the
bytes containing it, and deleting those bytes from the front
of \f(CW$bytes\fR.
Returns undef if no next message is available.
.SS "\->decode ($bytes)"
.IX Subsection "->decode ($bytes)"
Decodes bytes in \f(CW$bytes\fR, and returns ($ok, \f(CW$msg\fR, \f(CW$result\fR)
where \f(CW$ok\fR == 1 and \f(CW$result\fR is the \s-1SATC\s0 message on success,
\&\f(CW$ok\fR == 0 and \f(CW$msg\fR is a human-readable error message on failure.
.SS "\->encode ($message)"
.IX Subsection "->encode ($message)"
Returns ($ok, \f(CW$msg\fR, \f(CW$bytes\fR) where \f(CW$ok\fR == 1 and \f(CW$bytes\fR is the
byte string of encoded \s-1SATC\s0 message \f(CW$message\fR on success,
\&\f(CW$ok\fR == 0 and \f(CW$msg\fR is a human-readable error message on failure.
The encoded byte string includes the terminating newline.
This method is forgiving (perhaps too forgiving) about missing
fields \- it replaces missing string fields with empty strings
and missing integer fields with 0.
The msgtype field, however, is never allowed to be missing.
.ie n .SS "$hashed = hashify ($to_hash, $preserve_prefix_count, $suffix_blocks_count);"
.el .SS "\f(CW$hashed\fP = hashify ($to_hash, \f(CW$preserve_prefix_count\fP, \f(CW$suffix_blocks_count\fP);"
.IX Subsection "$hashed = hashify ($to_hash, $preserve_prefix_count, $suffix_blocks_count);"
Given string to_hash, returns a hash string of max length
preserve_prefix_count + suffix_blocks_count*11
with preserve_prefix_count chars at beginning untouched,
and the remaining chars hashed into suffix_blocks_count*11
characters.
.SH "AUTHOR"
.IX Header "AUTHOR"
Doug Campbell, \f(CW\*(C`<soup at ampersand.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-satc at rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Satc>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Satc
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (C) 2006,2007 Ampersand Inc., and Doug Campbell
.PP
This file is part of Satc.
.PP
Satc is free software; you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.
.PP
Satc is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the
\&\s-1GNU\s0 General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with Satc; if not, see <http://www.gnu.org/licenses/>.
